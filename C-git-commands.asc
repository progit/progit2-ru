[[C-git-commands]]
[appendix]
== Команды Git

В этой книге было показано больше десятка различных команд Git и мы приложили много усилий, чтобы рассказать вам о них, выстроив некий логический порядок, постепенно внедряя команды в сюжет.
Но такой подход "размазал" описания команд по всей книге.

В этом приложении мы пройдёмся по всем командам, о которых шла речь, и сгруппируем их по смыслу.
Мы расскажем, что делает каждая команда и укажем главы в книге, где эта команда использовалась.

[TIP]
====
Можно использовать аббревиатуры для опций.
Например, можно использовать команду `git commit --a` вместо `git commit --amend`.
Сокращение применимо только для тех опций, первая буква в имени которых не является начальной для других.
При написании скриптов рекомендуется использовать полное название.
====

=== Настройка и конфигурация

Две довольно распространённые команды, используемые как сразу после установки Git, так и в повседневной практике для настройки и получения помощи -- это `config` и `help`.

==== git config

Сотни вещей в Git работают без всякой конфигурации, используя параметры по умолчанию.
Для большинства из них вы можете задать иные умолчания, либо вовсе использовать собственные значения.
Это включает в себя целый ряд настроек, начиная от вашего имени и заканчивая цветами в терминале и вашим любимым редактором.
Команда `config` хранит и читает настройки в нескольких файлах, так что вы можете задавать значения глобально или для конкретных репозиториев.

Команда `git config` используется практически в каждой главе этой книги.

В главе <<ch01-getting-started#r_first_time>> мы использовали эту команду для указания имени, адреса электронной почты и редактора ещё до того, как начать использовать Git.

В главе  <<ch02-git-basics#r_git_aliases>> мы показали, как можно использовать её для создания сокращённых вариантов команд с длинными списками опций, чтобы не печатать их все каждый раз.

В главе <<ch03-git-branching#r_rebasing>> мы использовали `config` чтобы задать поведение `--rebase` по умолчанию для команды `git pull`.

В главе <<ch07-git-tools#r_credential_caching>> мы использовали её для задания хранилища ваших HTTP паролей.

В главе <<ch08-customizing-git#r_keyword_expansion>> мы показали как настроить фильтры содержимого для данных, перемещаемых между индексом и рабочей директорией.

Ну и практически вся глава <<ch08-customizing-git#r_git_config>> посвящена этой команде.

[[r_core_editor]]
==== Команды git config core.editor

Согласно инструкциям, приведенным в главе <<ch01-getting-started#r_editor>>, большинство редакторов может быть установлено следующим образом:

.Исчерпывающий список команд по настройке `core.editor`
[cols="1,2",options="header"]
|==============================
|Редактор | Команда
|Atom |`git config --global core.editor "atom --wait"`
|BBEdit (Mac, with command line tools) |`git config --global core.editor "bbedit -w"`
|Emacs |`git config --global core.editor emacs`
|Gedit (Linux) |`git config --global core.editor "gedit --wait --new-window"`
|Gvim (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\Vim\vim72\gvim.exe' --nofork '%*'"` (смотри примечание ниже)
|Kate (Linux) |`git config --global core.editor "kate"`
|nano |`git config --global core.editor "nano -w"`
|Notepad (Windows 64-bit) |`git config core.editor notepad`
|Notepad++ (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\Notepad++\notepad++.exe' -multiInst -notabbar -nosession -noPlugin"` (смотри примечание ниже)
|Scratch (Linux)|`git config --global core.editor "scratch-text-editor"`
|Sublime Text (macOS) |`git config --global core.editor "/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl --new-window --wait"`
|Sublime Text (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\Sublime Text 3\sublime_text.exe' -w"` (смотри примечание ниже)
|TextEdit (macOS)|`git config --global --add core.editor "open -W -n"`
|Textmate |`git config --global core.editor "mate -w"`
|Textpad (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\TextPad 5\TextPad.exe' -m` (смотри примечание ниже)
|Vim |`git config --global core.editor "vim"`
|Visual Studio Code |`git config --global core.editor "code --wait"`
|VSCodium (Free/Libre Open Source Software Binaries of VSCode) | `git config --global core.editor "codium --wait"`
|WordPad |`git config --global core.editor '"C:\Program Files\Windows NT\Accessories\wordpad.exe"'"`
|Xi | `git config --global core.editor "xi --wait"`
|==============================

[NOTE]
====
Если у вас установлена 32 битная версия редактора в 64 битной системе, то путь к ней будет содержать `C:\Program Files (x86)\`, а не `C:\Program Files\` как указано в таблице выше.
====

==== git help

Команда `git help` служит для отображения встроенной документации Git о других командах.
И хотя мы приводим описания самых популярных команд в этой главе, полный список параметров и флагов каждой команды доступен через `git help <command>`.

Мы представили эту команду в главе <<ch01-getting-started#r_git_help>> и показали как её использовать, чтобы найти больше информации о команде `git shell` в главе <<ch04-git-on-the-server#r_setting_up_server>>.


=== Клонирование и создание репозиториев

Существует два способа создать Git репозиторий.
Первый -- клонировать его из существующего репозитория (например, по сети); второй -- создать репозиторий в существующей директории.

==== git init

Чтобы превратить обычную директорию в Git репозиторий и начать версионировать файлы в ней, просто запустите `git init`.

Впервые мы продемонстрировали эту команду в главе <<ch02-git-basics#r_getting_a_repo>> на примере создания нового репозитория для последующей работы с ним.

Мы немного поговорили о смене названия ветки по умолчанию с "master" на что-нибудь другое в главе <<ch03-git-branching#r_remote_branches>>.

Мы использовали эту команду для создания чистого репозитория для работы на стороне сервера в главе <<ch04-git-on-the-server#r_bare_repo>>.

Ну и наконец мы немного покопались во внутренностях этой команды в главе <<ch10-git-internals#r_plumbing_porcelain>>.

==== git clone

На самом деле `git clone` работает как обёртка над некоторыми другими командами.
Она создаёт новую директорию, переходит внутрь и выполняет `git init` для создания пустого репозитория, затем она добавляет новый удалённый репозиторий (`git remote add`) для указанного URL (по умолчанию он получит имя `origin`), выполняет `git fetch` для этого репозитория и, наконец, обновляет вашу рабочую директорию до последнего коммита, используя `git checkout`.

Команда `git clone` используется в десятке различных мест в этой книге, но мы перечислим наиболее интересные упоминания.

Первоначальное знакомство происходит в главе <<ch02-git-basics#r_git_cloning>>, где мы даём немного объяснений и приводим несколько примеров.

В главе <<ch04-git-on-the-server#r_git_on_the_server>> мы рассмотрели как использовать опцию `--bare`, чтобы создать копию Git репозитория без рабочей директории.

В главе <<ch07-git-tools#r_bundling>> мы использовали `git clone` для распаковки упакованного с помощью `git bundle` репозитория.

Наконец, в главе <<ch07-git-tools#r_cloning_submodules>> мы научились использовать опцию `--recursive` чтобы упростить клонирование репозитория с субмодулями.

И хотя `git clone` используется во многих других местах в книге, перечисленные выше так или иначе отличаются от других вариантов использования.


=== Основные команды

Всего несколько команд нужно для базового варианта использования Git для ведения истории изменений.

==== git add

Команда `git add` добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита.
По умолчанию `git commit` использует лишь этот индекс, так что вы можете использовать `git add` для сборки слепка вашего следующего коммита.

Это одна из ключевых команд Git, мы упоминали о ней десятки раз на страницах книги.
Ниже перечислены наиболее интересные варианты использования этой команды.

Знакомство с этой командой происходит в главе <<ch02-git-basics#r_tracking_files>>.

О том как использовать `git add` для разрешения конфликтов слияния написано в главе <<ch03-git-branching#r_basic_merge_conflicts>>.

В главе <<ch07-git-tools#r_interactive_staging>> показано как использовать `git add` для добавления в индекс лишь отдельных частей изменённого файла.

В главе <<ch10-git-internals#r_tree_objects>> показано как эта команда работает на низком уровне, чтобы вы понимали, что происходит за кулисами.

==== git status

Команда `git status` показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе.
Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

Мы познакомили вас с этой командой в главе <<ch02-git-basics#r_checking_status>>, разобрали стандартный и упрощённый формат вывода.
И хотя мы использовали `git status` повсеместно в этой книге, практически все варианты использования покрыты в указанной главе.

==== git diff

Команда `git diff` используется для вычисления разницы между любыми двумя Git деревьями.
Это может быть разница между вашей рабочей директорией и индексом (собственно `git diff`), разница между индексом и последним коммитом (`git diff --staged`), или между любыми двумя коммитами (`git diff master branchB`).

Мы познакомили вас с основами этой команды в главе <<ch02-git-basics#r_git_diff_staged>>, где показали как посмотреть какие изменения уже добавлены в индекс, а какие -- ещё нет.

О том как использовать эту команду для проверки на проблемы с пробелами с помощью аргумента `--check` можно почитать в главе <<ch05-distributed-git#r_commit_guidelines>>.

Мы показали вам как эффективно сравнивать ветки используя синтаксис `git diff A...B` в главе <<ch05-distributed-git#r_what_is_introduced>>.

В главе <<ch07-git-tools#r_advanced_merging>> показано использование опции `-w` для скрытия различий в пробельных символах, а также рассказано как сравнивать конфликтующие изменения с опциями `--theirs`, `--ours` и `--base`.

Использование этой команды с опцией `--submodule` для сравнения изменений в субмодулях показано в главе <<ch07-git-tools#r_starting_submodules>>.

==== git difftool

Команда `git difftool` просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика `git diff`.

Мы лишь вкратце упомянули о ней в главе <<ch02-git-basics#r_git_diff_staged>>.

==== git commit

Команда `git commit` берёт все данные, добавленные в индекс с помощью `git add`, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

Вы познакомились с основами модели коммитов в главе <<ch02-git-basics#r_committing_changes>>.
Там же мы продемонстрировали использование опций `-a` для добавления всех изменений в индекс без использования `git add`, что может быть удобным в повседневном использовании, и `-m` для передачи сообщения коммита без запуска полноценного редактора.

В главе <<ch02-git-basics#r_undoing>> мы рассказали об опции `--amend`, используемой для изменения последнего совершённого коммита.

В главе <<ch03-git-branching#r_git_branches_overview>> мы более подробно познакомились с тем, что делает команда `git commit` и почему она делает это именно так.

Мы показали вам как подписывать ваши коммиты, используя опцию `-S` в главе <<ch07-git-tools#r_signing_commits>>.

И наконец мы заглянули внутрь команды `git commit` в главе <<ch10-git-internals#r_git_commit_objects>> и узнали что она делает за кулисами.

==== git reset

Команда `git reset`, как можно догадаться из названия, используется в основном для отмены изменений.
Она изменяет указатель `HEAD` и, опционально, состояние индекса.
Также эта команда может изменить файлы в рабочей директории при использовании параметра `--hard`, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

Мы рассказали об основах использования `git reset` в главе <<ch02-git-basics#r_unstaging>>, где эта команда использовалась для удаления файла из индекса, добавленного туда с помощью `git add`.

В главе <<ch07-git-tools#r_git_reset>>, полностью посвящённой этой команде, мы разобрались в деталях её использования.

Мы использовали `git reset --hard` чтобы отменить слияние в главе <<ch07-git-tools#r_abort_merge>>, там же было продемонстрировано использование команды `git merge --abort` для этих целей, которая работает как обёртка над `git reset`.

==== git rm

Команда `git rm` используется в Git для удаления файлов из индекса и рабочей директории.
Она похожа на `git add` с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

Мы немного разобрались с этой командой в главе <<ch02-git-basics#r_removing_files>>, показали как удалять файлы из рабочей директории и индекса и только из индекса, используя флаг `--cached`.

Ещё один вариант использования `git rm` приведён в главе <<ch10-git-internals#r_removing_objects>>, где мы вкратце объяснили как использовать опцию `--ignore-unmatch` при выполнении `git filter-branch`, которая подавляет ошибки удаления несуществующих файлов.
Это может быть полезно для автоматически выполняемых скриптов.

==== git mv

Команда `git mv` -- это всего лишь удобный способ переместить файл, а затем выполнить `git add` для нового файла и `git rm` для старого.

Мы лишь вкратце упомянули эту команду в главе <<ch02-git-basics#r_git_mv>>.

==== git clean

Команда `git clean` используется для удаления мусора из рабочей директории.
Это могут быть результаты сборки проекта или файлы конфликтов слияний.

Мы рассмотрели множество опций и сценариев использования этой команды в главе <<ch07-git-tools#r_git_clean>>.

=== Ветвление и слияния

За создание новых веток и слияние их воедино отвечает несколько Git команд.

==== git branch

Команда `git branch` -- это своего рода "менеджер веток".
Она умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.

Большая часть главы <<ch03-git-branching#ch03-git-branching>> посвящена этой команде, она используется повсеместно в этой главе.
Впервые команда `branch` была представлена в разделе <<ch03-git-branching#r_create_new_branch>>, а большинство таких её возможностей как перечисление и удаление веток были разобраны в разделе <<ch03-git-branching#r_branch_management>>.

В главе <<ch03-git-branching#r_tracking_branches>> мы показали как использовать сочетание `git branch -u` для отслеживания веток.

Наконец, мы разобрались что происходит за кулисами этой команды в главе <<ch10-git-internals#r_git_refs>>.

==== git checkout

Команда `git checkout` используется для переключения веток и выгрузки их содержимого в рабочую директорию.

Мы познакомились с этой командой в главе <<ch03-git-branching#r_switching_branches>> вместе с `git branch`.

В главе <<ch03-git-branching#r_tracking_branches>> мы узнали как использовать флаг `--track` для отслеживания веток.

В главе <<ch07-git-tools#r_checking_out_conflicts>> мы использовали эту команду с опцией `--conflict=diff3` для разрешения конфликтов заново, в случае если предыдущее решение не подходило по некоторым причинам.

Мы рассмотрели детали взаимосвязи этой команды и `git reset` в главе <<ch07-git-tools#r_git_reset>>.

Мы исследовали внутренние механизмы этой команды в главе <<ch10-git-internals#r_the_head>>.

==== git merge

Команда `git merge` используется для слияния одной или нескольких веток в текущую.
Затем она устанавливает указатель текущей ветки на результирующий коммит.

Мы познакомили вас с этой командой в главе <<ch03-git-branching#r_basic_branching>>.
И хотя `git merge` встречается в этой книге повсеместно, практически все использования имеют вид `git merge <branch>` с указанием единственной ветки для слияния.

Мы узнали как делать "сплющенные" слияния (когда Git делает слияние в виде нового коммита, без сохранения всей истории работы) в конце главы <<ch05-distributed-git#r_public_project>>.

В главе <<ch07-git-tools#r_advanced_merging>> мы глубже разобрались с процессом слияния и этой командой, включая флаги `-Xignore-all-whitespace` и `--abort`, используемый для отмены слияния в случае возникновения проблем.

Мы научились проверять криптографические подписи перед слияниями если ваш проект использует GPG в главе <<ch07-git-tools#r_signing_commits>>.

Ну и наконец в главе <<ch07-git-tools#r_subtree_merge>> мы познакомились со слиянием поддеревьев.

==== git mergetool

Команда `git mergetool` просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

Мы вкратце упомянули о ней в главе <<ch03-git-branching#r_basic_merge_conflicts>> и рассказали как настроить свою программу слияния в главе <<ch08-customizing-git#r_external_merge_tools>>.

==== git log

Команда `git log` используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта.
По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток.
Также её можно использовать для просмотра различий между ветками на уровне коммитов.

Практически во всех главах книги эта команда используется для демонстрации истории проекта.

Мы познакомились c `git log` и некоторыми её деталями в главе <<ch02-git-basics#r_viewing_history>>.
Там мы видели использование опций `-p` и `--stat` для получения представления об изменениях в каждом коммите, а также `--pretty` and `--oneline` для настройки формата вывода этой команды -- более полным и подробным или кратким.

В главе <<ch03-git-branching#r_create_new_branch>> мы использовали опцию `--decorate` чтобы отобразить указатели веток на истории коммитов, а также `--graph` чтобы просматривать историю в виде дерева.

В главах <<ch05-distributed-git#r_private_team>> и <<ch07-git-tools#r_commit_ranges>> мы рассмотрели синтаксис `branchA..branchB` для просмотра уникальных для заданной ветки коммитов.
Мы часто использовали этот приём в <<ch07-git-tools#r_commit_ranges>>.

В главах <<ch07-git-tools#r_merge_log>> и <<ch07-git-tools#r_triple_dot>> мы рассмотрели синтаксис `branchA...branchB` и опцию `--left-right` для просмотра что находится в первой, либо второй ветке, но не сразу в обеих.
Также в главе <<ch07-git-tools#r_merge_log>> рассмотрели опцию `--merge`, которая может быть полезной при разрешении конфликтов, а также `--cc` для просмотра конфликтов слияния в истории проекта.

В главе <<ch07-git-tools#r_git_reflog>> мы использовали опцию `-g` для вывода `git reflog`, используя `git log`.

В главе <<ch07-git-tools#r_searching>> мы рассмотрели использование опций `-S` и `-L` для поиска событий в истории проекта, например, истории развития какой-либо фичи.

В главе <<ch07-git-tools#r_signing_commits>> мы показали, как использовать опцию `--show-signature` для отображения строки валидации подписи для каждого коммита в `git log`.

==== git stash

Команда `git stash` используется для временного сохранения всех незакоммиченных изменений для очистки рабочей директории без необходимости коммитить незавершённую работу в новую ветку.

Эта команда практически целиком раскрыта в главе <<ch07-git-tools#r_git_stashing>>.

==== git tag

Команда `git tag` используется для задания постоянной метки на какой-либо момент в истории проекта.
Обычно она используется для релизов.

Мы познакомились и разобрались с ней в главе <<ch02-git-basics#r_git_tagging>> и использовали на практике в <<ch05-distributed-git#r_tagging_releases>>.

Мы научились создавать подписанные с помощью GPG метки, используя флаг `-s`, и проверять их, используя флаг `-v`, в главе <<ch07-git-tools#r_signing>>.


=== Совместная работа и обновление проектов

Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта.
Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

==== git fetch

Команда `git fetch` связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

Мы познакомились с ней в главе <<ch02-git-basics#r_fetching_and_pulling>> и продолжили знакомство в <<ch03-git-branching#r_remote_branches>>.

Мы использовали эту команду в нескольких примерах из главы <<ch05-distributed-git#r_contributing_project>>.

Мы использовали её для скачивания запросов на слияние (pull request) из других репозиториев в главе <<ch06-github#r_pr_refs>>, также мы рассмотрели использование `git fetch` для работы с упакованными репозиториями в главе <<ch07-git-tools#r_bundling>>.

Мы рассмотрели тонкую настройку `git fetch` в главe и <<ch10-git-internals#r_refspec>>.

==== git pull

Команда `git pull` работает как комбинация команд `git fetch` и `git merge`, т.е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

Мы познакомились с ней в главе <<ch02-git-basics#r_fetching_and_pulling>> и показали как узнать, какие изменения будут приняты в случае применения в главе <<ch02-git-basics#r_inspecting_remote>>.

Мы также увидели как она может оказаться полезной для разрешения сложностей при перемещении веток в главе <<ch03-git-branching#r_rebase_rebase>>.

Мы показали как можно использовать только URL удалённого репозитория без сохранения его в списке удалённых репозиториев в главе <<ch05-distributed-git#r_checking_out_remotes>>.

И наконец мы показали как проверять криптографические подписи полученных коммитов, используя опцию `--verify-signatures` в главе <<ch07-git-tools#r_signing_commits>>.

==== git push

Команда `git push` используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий.
Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

Мы познакомились с этой командой в главе <<ch02-git-basics#r_pushing_remotes>>.
Там мы рассмотрели основы обновления веток в удалённом репозитории.
В главе <<ch03-git-branching#r_pushing_branches>> мы подробнее познакомились с этой командой, а в <<ch03-git-branching#r_tracking_branches>> мы узнали как настроить отслеживание веток для автоматической передачи на удалённый репозиторий.
В главе <<ch03-git-branching#r_delete_branches>> мы использовали флаг `--delete` для удаления веток на сервере, используя `git push`.

На протяжении главы <<ch05-distributed-git#r_contributing_project>> мы показали несколько примеров использования `git push` для совместной работы в нескольких удалённых репозиториях одновременно.

В главе <<ch07-git-tools#r_publishing_submodules>> мы использовали опцию `--recurse-submodules` чтобы удостовериться, что все субмодули будут опубликованы перед отправкой на проекта на сервер, что может быть реально полезным при работе с репозиториями, содержащими субмодули.

В главе <<ch08-customizing-git#r_other_client_hooks>> мы поговорили о триггере `pre-push`, который может быть выполнен перед отправкой данных, чтобы проверить возможность этой отправки.

Наконец, в главе <<ch10-git-internals#r_pushing_refspecs>> мы рассмотрели передачу данных с полным указанием передаваемых ссылок, вместо использования распространённых сокращений.
Это может быть полезным если вы хотите очень точно указать, какими изменениями хотите поделиться.

==== git remote

Команда `git remote` служит для управления списком удалённых репозиториев.
Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например "origin", так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером.
Вы можете использовать несколько удалённых репозиториев для работы и `git remote` поможет добавлять, изменять и удалять их.

Эта команда детально рассмотрена в главе <<ch02-git-basics#r_remote_repos>>, включая вывод списка удалённых репозиториев, добавление новых, удаление или переименование существующих.

Она используется практически в каждой главе, но всегда в одном и том же виде: `git remote add <имя> <URL>`.

==== git archive

Команда `git archive` используется для упаковки в архив указанных коммитов или всего репозитория.

Мы использовали `git archive` для создания тарбола (`tar.gz` файла) всего проекта для передачи по сети в главе <<ch05-distributed-git#r_preparing_release>>.

==== git submodule

Команда  `git submodule` используется для управления вложенными репозиториями.
Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы.
У команды `submodule` есть несколько под-команд -- `add`, `update`, `sync` и др. -- для управления такими репозиториями.

Эта команда упомянута и полностью раскрыта в главе <<ch07-git-tools#r_git_submodules>>.

=== Осмотр и сравнение

==== git show

Команда `git show` отображает объект в простом и человекопонятном виде.
Обычно она используется для просмотра информации о метке или коммите.

Впервые мы использовали её для просмотра информации об аннотированной метке в главе <<ch02-git-basics#r_annotated_tags>>.

В главе <<ch07-git-tools#r_revision_selection>> мы использовали её для показа коммитов, подпадающих под различные селекторы диапазонов.

Ещё одна интересная вещь, которую мы проделывали с помощью `git show` в главе <<ch07-git-tools#r_manual_remerge>> -- это извлечение содержимого файлов на различных стадиях во время конфликта слияния.

==== git shortlog

Команда `git shortlog` служит для подведения итогов команды `git log`.
Она принимает практически те же параметры, что и `git log`, но вместо простого листинга всех коммитов, они будут сгруппированы по автору.

Мы показали, как можно использовать эту команду для создания классных списков изменений (changelogs) в главе <<ch05-distributed-git#r_the_shortlog>>.

==== git describe

Команда `git describe` принимает на вход что угодно, что можно трактовать как коммит (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коммита.
Это может быть использовано как более удобная, но по-прежнему уникальная, замена SHA-1.

Мы использовали `git describe` в главах <<ch05-distributed-git#r_build_number>> и <<ch05-distributed-git#r_preparing_release>> чтобы сгенерировать название для архивного файла с релизом.


=== Отладка

В Git есть несколько команд, используемых для нахождения проблем в коде.
Это команды для поиска места в истории, где проблема впервые проявилась и собственно виновника этой проблемы.

==== git bisect

Команда `git bisect` -- это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

О ней упоминается только в главе <<ch07-git-tools#r_binary_search>>, где она полностью и раскрыта.

==== git blame

Команда `git blame` выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита.
Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

Эта команда полностью разобрана в главе <<ch07-git-tools#r_file_annotation>>.

==== git grep

Команда `git grep` используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.

Она полностью разобрана в разделе <<ch07-git-tools#r_git_grep>> и упоминается лишь там.

=== Внесение исправлений

Некоторые команды в Git основываются на подходе к рассмотрению коммитов в терминах внесённых ими изменений, т.е. рассматривают историю коммитов как цепочку патчей.
Ниже перечислены эти команды.

==== git cherry-pick

Команда `git cherry-pick` используется для того чтобы взять изменения, внесённые каким-либо коммитом, и попытаться применить их заново в виде нового коммита наверху текущей ветки.
Это может оказаться полезным чтобы забрать парочку коммитов из другой ветки без полного слияния с той веткой.

Мы продемонстрировали работу этой команды в главе <<ch05-distributed-git#r_rebase_cherry_pick>>.

==== git rebase

`git rebase` -- это "автоматизированный" `cherry-pick`.
Он выполняет ту же работу, но для цепочки коммитов, тем самым как бы перенося ветку на новое место.

Мы в деталях разобрались с механизмом переноса веток в главе <<ch03-git-branching#r_rebasing>>, включая рассмотрение потенциальных проблем переноса опубликованных веток при совместной работе.

Мы использовали эту команду на практике для разбиения истории на два репозитория в главе <<ch07-git-tools#r_replace>>, наряду с использованием флага `--onto`.

В главе <<ch07-git-tools#r_rerere>> мы рассмотрели случай возникновения конфликта во время переноса коммитов.

Также мы познакомились с интерактивным вариантом `git rebase`, включающемся с помощью опции `-i`, в главе <<ch07-git-tools#r_changing_multiple>>.

==== git revert

Команда `git revert` -- полная противоположность `git cherry-pick`.
Она создаёт "антикоммит" для указанного коммита, таким образом отменяя изменения, внесённые в нём..

Мы использовали её в главе <<ch07-git-tools#r_reverse_commit>> чтобы отменить коммит слияния (merge commit).

=== Работа с помощью электронной почты

Множество проектов, использующих Git (включая сам Git), активно используют списки рассылок для координирования процесса разработки.
В Git есть несколько команд, помогающих в этом, начиная от генерации патчей, готовых к пересылке по электронной почте, заканчивая применением таких патчей прямиком из папки "входящие".

==== git apply

Команда `git apply` применяет патч, сформированный с помощью команды `git diff` или `GNU diff`.
Она делает практически то же самое, что и команда `patch`.

Мы продемонстрировали использование этой команды в главе <<ch05-distributed-git#r_patches_from_email>> и описали случаи, когда вы возможно захотите ею воспользоваться.

==== git am

Команда `git am` используется для применения патчей из ящика входящих сообщений электронной почты, в частности, тех что используют формат `mbox`.
Это используется для простого получения изменений через email и применения их к проекту.

Мы рассмотрели использование этой команды в главе <<ch05-distributed-git#r_git_am>>, включая такие опции как `--resolved`, `-i` и `-3`.

Существует набор триггеров, которые могут оказаться полезными при использовании `git am` для процесса разработки.
О них рассказано в главе <<ch08-customizing-git#r_email_hooks>>.

Также мы использовали `git am` для применения сформированного из Github'овского запроса на слияние patch-файла в главе <<ch06-github#r_email_notifications>>.

==== git format-patch

Команда `git format-patch` используется для создания набора патчей в формате `mbox` которые можно использовать для отправки в список рассылки.

Мы рассмотрели процесс отсылки изменений в проект, использующий email для разработки в главе <<ch05-distributed-git#r_project_over_email>>.

==== git send-email

Команда `git send-email` используется для отсылки патчей, сформированных с использованием `git format-patch`, по электронной почте.

Процесс отсылки изменений по электронной почте в проект рассмотрен в главе <<ch05-distributed-git#r_project_over_email>>.

==== git request-pull

Команда `git request-pull` используется для генерации примерного текста сообщения для отсылки кому-либо.
Если у вас есть ветка, хранящаяся на публичном сервере, и вы хотите чтобы кто-либо забрал эти изменения без возни с отсылкой патчей по электронной почте, вы можете выполнить эту команду и послать её вывод тому человеку.

Мы показали, как пользоваться этой командой в главе <<ch05-distributed-git#r_public_project>>.

=== Внешние системы

В Git есть несколько стандартных команд для работы с другими системами контроля версий.

==== git svn

Команда `git svn` используется для работы с сервером Subversion.
Это означает, что вы можете использовать Git в качестве SVN клиента, забирать изменения и отправлять свои собственные на сервер Subversion.

Мы разобрались с этой командой в главе <<ch09-git-and-other-scms#r_git_svn>>.

==== git fast-import

Для других систем контроля версий, либо для импорта произвольно форматированных данных, вы можете использовать `git fast-import`, которая умеет преобразовывать данные в формат, понятный Git.

Мы детально рассмотрели эту команду в главе  <<ch09-git-and-other-scms#r_custom_importer>>.

=== Администрирование

Если вы администрируете Git репозиторий или вам нужно исправить что-либо, Git предоставляет несколько административных команд вам в помощь.

==== git gc

Команда `git gc` запускает сборщик мусора в вашем репозитории, который удаляет ненужные файлы из хранилища объектов и эффективно упаковывает оставшиеся файлы.

Обычно, эта команда выполняется автоматически без вашего участия, но, если пожелаете, можете вызвать её вручную.
Мы рассмотрели некоторые примеры её использования в главе <<ch10-git-internals#r_git_gc>>.

==== git fsck

Команда `git fsck` используется для проверки внутренней базы данных на предмет наличия ошибок и несоответствий.

Мы лишь однажды использовали её в главе <<ch10-git-internals#r_data_recovery>> для поиска более недостижимых (dangling) объектов.

==== git reflog

Команда `git reflog` просматривает историю изменения голов веток на протяжении вашей работы для поиска коммитов, которые вы могли внезапно потерять, переписывая историю.

В основном, мы рассматривали эту команду в главе <<ch07-git-tools#r_git_reflog>>, где мы показали пример использования этой команды, а также как использовать `git log -g` для просмотра той же информации, используя `git log`.

Мы на практике рассмотрели восстановление потерянной ветки в главе <<ch10-git-internals#r_data_recovery>>.

==== git filter-branch

Команда `git filter-branch` используется для переписывания содержимого коммитов по заданному алгоритму, например, для полного удаления файла из истории или для вычленения истории лишь части файлов в проекте для вынесения в отдельный репозиторий.

В главе <<ch07-git-tools#r_removing_file_every_commit>> мы объяснили механизм работы этой команды и рассказали про использование опций `--commit-filter`, `--subdirectory-filter` и `--tree-filter`.

=== Низкоуровневые команды

Также в этой книге встречались некоторые низкоуровневые ("сантехнические") команды.

Первая из них -- это `ls-remote`, с которой мы столкнулись в главе <<ch06-github#r_pr_refs>> и использовали для просмотра ссылок на сервере.

В главах <<ch07-git-tools#r_manual_remerge>>, <<ch07-git-tools#r_rerere>> и <<ch07-git-tools#r_the_index>> мы использовали команду `ls-files` чтобы просмотреть "сырые" данные в индексе.

Мы также упоминали о команде `rev-parse` в главе <<ch07-git-tools#r_branch_references>>, используемой для превращения практически произвольно отформатированных строк в SHA-1 указатели.

Так или иначе, большинство низкоуровневых команд собрано в главе <<ch10-git-internals#ch10-git-internals>>, которая на них и сосредоточена.
Мы старались избегать этих команд в других местах в этой книге.

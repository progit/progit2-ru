[[r_rebasing]]
=== Перебазирование

(((rebasing)))
В GIT есть два способа внести изменения из одной ветки в другую: слияние и перебазирование.
В этом разделе вы узнаете что такое перебазирование, как его осуществлять и в каких случаях этот удивительный инструмент использовать не следует.

==== Простейшее перебазирование

Если вы вернетесь к более раннему примеру из <<r_basic_merging>>, вы увидите, что разделили свою работу и сделали коммиты в две разные ветки.

.История коммитов простого разделения
image::images/basic-rebase-1.png[История коммитов простого разделения.]

Как мы выяснили ранее, простейший способ выполнить слияние двух веток -- это команда `merge`.
Она осуществляет трехстороннее слияние между двумя последними снимками сливаемых веток (`C3` и `C4`) и самого недавнего общего для этих веток родительского снимка (`C2`), создавая новый снимок (и коммит).

[[r_rebasing-merging-example]]
.Слияние разделенной истории коммитов
image::images/basic-rebase-2.png[Слияние разделенной истории коммитов.]

Тем не менее, есть и другой способ: вы можете взять те изменения, что были представлены в `C4` и применить их поверх `C3`.
В Git это называется _перебазированием_.
С помощью команды `rebase` вы можете взять все коммиты из одной ветки и в том же порядке применить их к другой ветке.(((git commands, rebase)))

В данном примере переключимся на ветку `experiment` и перебазируем её относительно ветки `master` следующим образом:

[source,console]
----
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
----

Это работает следующим образом: берется общий родительский снимок двух веток (текущей, и той, поверх которой вы выполняете перебазирование), определяется дельта каждого коммита текущей ветки и сохраняется во временный файл, текущая ветка устанавливается на последний коммит ветки, поверх которой вы выполняете перебазирование, а затем по очереди применяются дельты из временных файлов.

.Перебазирование изменений из `C4` поверх `C3`
image::images/basic-rebase-3.png[Перебазирование изменений из `C4` поверх `C3`.]

После этого, вы можете переключиться обратно на ветку `master` и выполнить слияние перемоткой.

[source,console]
----
$ git checkout master
$ git merge experiment
----

.Перемотка ветки master
image::images/basic-rebase-4.png[Перемотка ветки master.]

Теперь снимок, на который указывает `C4'` абсолютно такой же, как тот, на который указывал `C5` в <<r_rebasing-merging-example,примере с трехсторонним слиянием>>.
Нет абсолютно никакой разницы в конечном результате между двумя показанными примерами, но перебазирование делает историю коммитов чище.
Если вы взглянете на историю перебазированной ветки, то увидите, что она выглядит абсолютно линейной: будто все операции были выполнены последовательно, даже если изначально они совершались параллельно.

Часто вы будете делать так для уверенности, что ваши коммиты могут быть бесконфликтно слиты в удалённую ветку -- возможно в проекте, куда вы пытаетесь внести вклад, но владельцем которого вы не являетесь.
В этом случае вам следует работать в своей ветке и затем перебазировать вашу работу поверх `origin/master`, когда вы будете готовы отправить свои изменения в основной проект.
Тогда владельцу проекта не придется делать никакой лишней работы -- все решится простой перемоткой или бесконфликтным слиянием.

Учтите, что снимок, на который ссылается ваш последний коммит -- является ли он последним коммитом после перебазирования или коммитом слияния после слияния -- в обоих случаях это один и тот же снимок, отличаются только истории коммитов.
Перебазирование повторяет изменения из одной ветки поверх другой в том порядке, в котором эти изменения были сделаны, в то время как слияние берет две конечные точки и сливает их вместе.

==== Более интересные перемещения

Также возможно сделать так, чтобы при перебазировании воспроизведение коммитов применялось к совершенно другой ветке.
Для примера возьмём <<rrbdiag_e>>.
Вы создаете тематическую ветку `server` чтобы добавить в проект некоторую функциональность для серверной части и делаете коммит. 
Затем вы выполнили ответвление чтобы сделать изменения для клиентской части и создали несколько коммитов.
Наконец, вы вернулись на ветку `server` и сделали ещё несколько коммитов.

[[rrbdiag_e]]
.История разработки с тематической веткой, ответвлённой от другой тематической ветки
image::images/interesting-rebase-1.png[История разработки с тематической веткой, ответвлённой от другой тематической ветки.]

Предположим, вы решили, что хотите внести изменения клиентской части в основную линию разработки для релиза, но при этом не хотите добавлять изменения серверной части до полного тестирования.
Вы можете взять изменения из ветки `client`, которых нет в `server` (`C8` и `C9`), и применить их на ветке `master` при помощи опции `--onto` команды `git rebase`:

[source,console]
----
$ git rebase --onto master server client
----

В этой команде говорится: ``Переключись на ветку `client`, найди изменения относительно ветки `server` и примени их для ветки `master`''.
Несмотря на некоторую сложность этого способа, результат впечатляет.

.Перемещение тематической ветки, ответвлённой от другой тематической ветки
image::images/interesting-rebase-2.png[Перемещение тематической ветки, ответвлённой от другой тематической ветки.]

Теперь вы можете выполнить перемотку (fast-forward) для ветки `master` (см <<rrbdiag_g>>):

[source,console]
----
$ git checkout master
$ git merge client
----

[[rrbdiag_g]]
.Перемотка ветки `master` для добавления изменений из ветки `client`
image::images/interesting-rebase-3.png[Перемотка ветки `master` для добавления изменений из ветки `client`.]

Представим, что вы решили добавить наработки и из ветки `server`. 
Вы можете выполнить перебазирование ветки `server` относительно ветки `master` без предварительного переключения на неё при помощи команды `git rebase <basebranch> <topicbranch>`, которая извлечёт тематическую ветку (в данном случае `server`) и применит изменения в ней к базовой ветке (`master`):

[source,console]
----
$ git rebase master server
----

Эта команда добавит изменения ветки `server` в ветку `master`, как это показано на <<rrbdiag_h>>.

[[rrbdiag_h]]
.Перебазироване ветки `server` на основании ветки `master`
image::images/interesting-rebase-4.png[Перебазироване ветки `server` на основании ветки `master`.]

После чего вы сможете выполнить перемотку основной ветки (`master`):

[source,console]
----
$ git checkout master
$ git merge server
----

Теперь вы можете удалить ветки `client` и `server`, поскольку весь ваш прогресс уже интегрирован и тематические ветки больше не нужны, а полную историю вашего рабочего процесса отражает рисунок <<rrbdiag_i>>:

[source,console]
----
$ git branch -d client
$ git branch -d server
----

[[rrbdiag_i]]
.Окончательная история коммитов
image::images/interesting-rebase-5.png[Окончательная история коммитов.]

[[r_rebase_peril]]
==== Опасности перемещения

(((rebasing, perils of)))
Но даже перебазирование, при всех своих достоинствах, не лишено недостатков, которые можно выразить одной строчкой:

**Не перемещайте коммиты, уже отправленные в публичный репозиторий**

Если вы будете придерживаться этого правила, всё будет хорошо.
Если не будете, люди возненавидят вас, а ваши друзья и семья будут вас презирать.

Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаёте новые, *похожие* на старые, но являющиеся другими.
Если вы куда-нибудь отправляете свои коммиты и другие люди забирают их себе и в дальнейшем основывают на них свою работу, а затем вы переделываете эти коммиты командой `git rebase` и выкладываете их снова, то ваши коллеги будут вынуждены заново выполнять слияние для своих наработок.
В итоге, когда вы в очередной раз попытаетесь включить их работу в свою, вы получите путаницу.

Давайте рассмотрим пример того, как перемещение публично доступных наработок может вызвать проблемы.
Предположим, вы склонировали репозиторий с сервера и сделали какую-то работу.
И ваша история коммитов выглядит так:

.Клонирование репозитория и выполнение в нем какой-то работы
image::images/perils-of-rebasing-1.png["Клонирование репозитория и выполнение в нем какой-то работы."]

Теперь кто-то другой внёс свои изменения, слил их и отправил на сервер.
Вы стягиваете их к себе, включая новую удаленную ветку, что изменяет вашу историю следующим образом:

.Извлекаем ещё коммиты и сливаем их со своей работой
image::images/perils-of-rebasing-2.png["Извлекаем ещё коммиты и сливаем их со своей работой."]

Затем, автор коммита слияния решает вернуться назад и перебазировать свою ветку; выполнив `git push --force` он перезаписывает историю на сервере.
При получении изменений с сервера вы получите и новые коммиты.

[[r_pre_merge_rebase_work]]
.Кто-то выложил перебазированные коммиты, отменяя коммиты, на которых основывалась ваша работа
image::images/perils-of-rebasing-3.png["Кто-то выложил перебазированные коммиты, отменяя коммиты, на которых основывалась ваша работа."]

Теперь вы оба в неловком положении.
Если вы выполните `git pull`, вы создадите коммит слияния, включающий обе линии истории, и ваш репозиторий будет выглядеть следующим образом:

[[r_merge_rebase_work]]
.Вы снова выполняете слияние для той же самой работы в новый коммит слияния
image::images/perils-of-rebasing-4.png[Вы снова выполняете слияние для той же самой работы в новый коммит слияния.]

Если вы посмотрите `git log` в этот момент, вы увидите два коммита с одинаковыми авторами, датой и сообщением, что может сбить с толку.
Помимо этого, если вы отправите свою историю на удаленный сервер в таком состоянии, вы вернете все эти перебазированные коммиты на сервер, что ещё больше всех запутает.
Логично предположить, что разработчик не хочет, чтобы `C4` и `C6` были в истории, и именно поэтому она перебазируется в первую очередь.

[[r_rebase_rebase]]
==== Меняя базу, меняй основание

Если вы попали в такую ситуацию, у Git есть особая магия чтобы вам помочь.
Если кто-то в вашей комаде форсирует отправку изменений на сервер, переписывающих работу на которых базировалась ваша работа, то ваша задача будет состоять в определении что именно было ваше, а что было переписано *ими*.

Оказывается, что помимо контрольной суммы коммита SHA-1, Git также вычисляет контрольную сумму отдельно для патча, входящего в этот коммит.
Это контрольная сумма называется ``patch-id''.

Если вы скачаете перезаписанную историю и перебазируете её поверх новых коммитов вашего коллеги, в большинстве случаев Git успешно определит какие именно изменения были внесены вами и применит их поверх новой ветки.

К примеру, если бы в предыдущем сценарии вместо слияния в <<r_pre_merge_rebase_work>> мы выполним `git rebase teamone/master`, Git будет:

* Определять, какая работа уникальна для вашей ветки (C2, C3, C4, C6, C7)
* Определять, какие коммиты не были коммитами слияния (C2, C3, C4)
* Определять, что не было перезаписано в основной ветке (только C2 и C3, поскольку C4 -- это тот же патч, что и C4')
* Применять эти коммиты к ветке `teamone/master`

Таким образом, вместо результата, который мы можем наблюдать на <<r_merge_rebase_work>>, у нас получилось бы что-то вроде <<r_rebase_rebase_work>>.

[[r_rebase_rebase_work]]
.Перемещение в начало force-pushed перемещенной работы.
image::images/perils-of-rebasing-5.png[Перемещение в начало force-pushed перемещенной работы.]

Это возможно, если `C4` и `C4'` фактически являются одним и тем же патчем, который был сделан вашим коллегой.
В противном случае `rebase` не сможет определить дубликат и создаст ещё один патч, подобный C4 (который с большой вероятностью не удастся применить чисто, поскольку в нём уже присутствуют некоторые изменения).

Вы можете это упростить, применив `git pull --rebase` вместо обычного `git pull`.
Или сделать это вручную с помощью `git fetch`, а затем `git rebase teamone/master`.

Если вы используете `git pull` и хотите использовать `--rebase` по умолчанию, вы можете установить соответствующее значение конфигурации `pull.rebase` с помощью команды `git config --global pull.rebase true`. 

Если вы рассматриваете перебазирование как способ наведения порядка и работаете с коммитами локально до их отправки или ваши коммиты никогда не будут доступны публично -- у вас всё будет хорошо. 
Однако, если вы перемещаете коммиты, отправленные в публичный репозиторий, и есть вероятность, что работа некоторых людей основывается на этих коммитах, то ваши действия могут вызвать существенные проблемы, а вы -- вызвать презрение вашей команды. 

Если в какой-то момент вы или ваш коллега находите необходимость в этом, убедитесь, что все знают, как применять команду `git pull --rebase` для минимизации последствий от подобных действий.

==== Перемещение vs. Слияние

(((rebasing, vs. merging)))(((merging, vs. rebasing)))
Теперь, когда вы увидели перемещение и слияние в действии, вы можете задаться вопросом, что из них лучше.
Прежде чем ответить на этот вопрос, давайте вернёмся немного назад и поговорим о том, что означает история.

Одна из точек зрения заключается в том, что история коммитов в вашем репозиториии -- это *запись того, что на самом деле произошло*.
Это исторический документ, ценный сам по себе, и его нельзя подделывать.
С этой точки зрения изменение истории коммитов практически кощунственно; вы _лжете_ о том, что на самом деле произошло.
Но что, если произошла путаница в коммитах слияния?
Если это случается, репозиторий должен сохранить это для потомков.

Противоположная точка зрения заключается в том, что история коммитов -- это *история того, как был сделан ваш проект*.
Вы не публикуете первый черновик книги или инструкции по поддержке вашего программного обеспечения, так как это нуждается в тщательном редактировании.
Сторонники этого лагеря считают использование инструментов `rebase` и `filter-branch` способом рассказать историю проекта наилучшим образом для будущих читателей.

Теперь к вопросу о том, что лучше -- слияние или перебазирование: надеюсь, вы видите, что это не так просто.
Git -- мощный инструмент, позволяющий вам делать многое с вашей историей, однако каждая команда и каждый проект индивидуален.
Теперь, когда вы знаете, как работают оба эти приёма, выбор -- какой из них будет лучше в вашей ситуации -- решать вам.

В основном, стоит взять лучшее от обоих миров -- использовать перебазирование для наведения порядка в истории ваших локальных изменений, ещё не отправленных на удаленный сервер, но никогда не применять перебазирование для уже отправленных куда-нибудь изменений.

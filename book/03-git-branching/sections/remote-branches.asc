[[_remote_branches]]
=== Удалённые ветки

(((branches, remote)))(((references, remote)))
Удалённые ветки — это ссылки (pointers) на состояние веток в ваших удалённых репозиториях.
Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети.
Удалённые ветки действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.

Они выглядят как `(имя удал. репоз.)/(ветка)`.
Например, если вы хотите посмотреть, как выглядела ветка `master` на сервере `origin` во время последнего соединения с ним, проверьте ветку `origin/master`.
Если вы с партнёром работали над одной проблемой, и он выложил ветку `iss53`, у вас может быть своя локальная ветка `iss53`; но та ветка на сервере будет указывать на коммит в `origin/iss53`.

Всё это, возможно, сбивает с толку, поэтому давайте рассмотрим пример.
Скажем, у вас в сети есть свой Git-сервер на `git.ourcompany.com`.
Если вы с него что-то склонируете, Git-команда `clone` автоматически назовёт его `origin`, заберёт оттуда все данные, создаст указатель на то, на что там указывает ветка `master`, и назовёт его локально `origin/master`.
Git также сделает вам вашу собственную локальную ветку `master`, которая будет начинаться там же, где и ветка `master` в origin, так что вам будет с чем работать.

[NOTE]
.``origin'' — это не специальное название
====
Подобно тому, как название ветки ``master'' не имеет какого-либо специального значения в Git, также и название ``origin''. В то время как ``master'' — это название по умолчанию для исходной ветки, когда вы запускаете `git init`, по единственной причине, что широко используется, ``origin'' — это название по умолчанию для удаленной ветки, когда вы запускаете `git clone`. Если вы запустите `git clone -o booyah`, так вы будете иметь `booyah/master` как вашу удаленную ветку по умолчанию.(((origin)))
====

.Серверный и локальный репозитории после клонирования
image::images/remote-branches-1.png[Серверный и локальный репозитории после клонирования.]

Если вы сделаете что-то в своей локальной ветке `master`, а тем временем кто-то ещё отправит (push) изменения на `git.ourcompany.com` и обновит там ветку `master`, то ваши истории продолжатся по-разному.
Ещё, до тех пор, пока вы не свяжетесь с сервером origin, ваш указатель `origin/master` не будет сдвигаться.

.Локальная и удаленная работа может расходиться
image::images/remote-branches-2.png[Локальная и удаленная работа может расходиться.]

Для синхронизации вашей работы выполняется команда `git fetch origin`.
Эта команда ищет, какому серверу соответствует ``origin'' (в нашем случае это `git.ourcompany.com`); извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное хранилище данных; сдвигает указатель `origin/master` на новую позицию.

.`git fetch` обновляет ваши удаленные ссылки
image::images/remote-branches-3.png[`git fetch` обновляет ваши удаленные ссылки.]

Чтобы продемонстрировать то, как будут выглядеть удалённые ветки в ситуации с несколькими удалёнными серверами, предположим, что у вас есть ещё один внутренний Git-сервер, который используется для разработки только одной из ваших команд разработчиков.
Этот сервер находится на `git.team1.ourcompany.com`. 
Вы можете добавить его в качестве новой удалённой ссылки на проект, над которым вы сейчас работаете с помощью команды `git remote add` так же, как было описано в <<_git_basics_chapter>>.
Дайте этому удалённому серверу имя `teamone`, которое будет сокращением для полного URL.

.Добавление еще одного сервера в качестве удаленной ветки
image::images/remote-branches-4.png[Добавление еще одного сервера в качестве удаленной ветки.]

Теперь можете выполнить `git fetch teamone`, чтобы извлечь всё, что есть на сервере и нет у вас.
Так как в данный момент на этом сервере есть только часть данных, которые есть на сервере `origin`, Git не получает никаких данных, но выставляет удалённую ветку с именем `teamone/master`, которая указывает на тот же коммит, что и ветка `master` на сервере `teamone`.

.Удаленное отслеживание ветки `teamone/master`
image::images/remote-branches-5.png[Удаленное отслеживание ветки `teamone/master`.]

[[_pushing_branches]]
==== Отправка изменений

(((pushing)))
Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её на удалённый сервер, на котором у вас есть права на запись.
Ваши локальные ветки автоматически не синхронизируются с удалёнными серверами — вам нужно явно отправить те ветки, которыми вы хотите поделиться.
Таким образом, вы можете использовать свои личные ветки для работы, которую вы не хотите показывать, и отправлять только те тематические ветки, над которыми вы хотите работать с кем-то совместно.

Если у вас есть ветка `serverfix`, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же, как вы отправляли вашу первую ветку.
Выполните `git push (удал. сервер) (ветка)`:(((git commands, push)))

[source,console]
----
$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -> serverfix
----

Это в некотором роде сокращение.
Git автоматически разворачивает имя ветки `serverfix` до `refs/heads/serverfix:refs/heads/serverfix`, что означает ``возьми мою локальную ветку serverfix и обнови ей удалённую ветку serverfix.''
Мы подробно обсудим часть с `refs/heads/` в <<_git_internals>>, но обычно её можно опустить.
Вы также можете выполнить `git push origin serverfix:serverfix` — произойдёт то же самое — здесь говорится ``возьми мой serverfix и сделай его удалённым serverfix.''
Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем.
Если вы не хотите, чтобы ветка называлась `serverfix` на удалённом сервере, то вместо предыдущей команды выполните `git push origin serverfix:awesomebranch`. Так ваша локальная ветка `serverfix` отправится в ветку `awesomebranch` удалённого проекта.

[NOTE]
.Не вводите каждый раз свой пароль
====
Если вы используете HTTPS URL для отправки изменений, Git-сервер спросит имя пользователя и пароль для аутентификации. По умолчанию вам будет предложено ввести в терминале эту информацию, чтобы сервер мог сказать, что вам разрешена отправка изменений.

Если вы не хотите каждый раз вводить ваши данные, когда вы отправляете изменения, вы можете установить ``кэш учетных данных''. Проще всего просто держать их в памяти несколько минут, вы можете легко настроить с помощью команды `git config --global credential.helper cache`.

Для получения более подробной информации о различных вариантах кэша учетных данных, можно посмотреть на <<_credential_caching>>.
====

В следующий раз, когда один из ваших соавторов будет получать обновления с сервера, он получит ссылку на то, на что указывает `serverfix` на сервере, как удалённую ветку `origin/serverfix`:

[source,console]
----
$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix
----

Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий.
Другими словами, в нашем случае вы не получите новую ветку `serverfix` — только указатель `origin/serverfix`, который вы не можете менять.

Чтобы слить эти наработки в свою текущую рабочую ветку, выполните `git merge origin/serverfix`.
Если вам нужна своя собственная ветка `serverfix`, над которой вы сможете работать, то вы можете создать её на основе удалённой ветки:

[source,console]
----
$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

Это даст вам локальную ветку, на которой можно работать. Она будет начинаться там, где и `origin/serverfix`.

[[_tracking_branches]]
==== Отслеживание веток

(((branches, tracking)))(((branches, upstream)))
Получение локальной ветки из удалённой ветки автоматически создаёт то, что называется ``отслеживаемой веткой'' (или иногда ``upstream branch'').
Отслеживаемые ветки — это локальные ветки, которые напрямую связаны с удалённой веткой.
Если, находясь на отслеживаемой ветке, вы наберёте `git pull`, Git уже будет знать, с какого сервера получить все удалённые ссылки и сделает слияние с соответствующей удалённой веткой. Аналогично выполнение `git pull` на одной из таких веток, сначала получает все удалённые ссылки, а затем автоматически делает слияние с соответствующей удалённой веткой.

При клонировании репозитория, как правило, автоматически создаётся ветка `master`, которая отслеживает `origin/master`.
Однако, вы можете настроить отслеживание и других веток, допустим если вы хотите, чтобы одни ветки отслеживались с другого удаленного репозитория или не хотите отслеживать ветку `master`.
Простой пример, как это сделать, вы увидели только что — `git checkout -b [ветка] [удал. сервер]/[ветка]`.
Существует общепринятая операция, которую git предоставляет, `--track`:

[source,console]
----
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

Чтобы настроить локальную ветку с именем, отличным от имени удалённой ветки, вы можете легко использовать первую версию с другим именем локальной ветки:

[source,console]
----
$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
----

Теперь ваша локальная ветка sf будет автоматически получать (pull) изменения из origin/serverfix.

Если у вас уже есть локальная ветка и вы хотите настроить ее на удаленную ветку, которую вы только получили, или хотите изменить upstream-ветку, которую вы отслеживаете, вы можете воспользоваться ключами `-u` или `--set-upstream-to` с командой `git branch`, чтобы явно установить ее в любое время.

[source,console]
----
$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
----

[NOTE]
.Сокращение Upstream
====
Если у вас есть установленная отслеживаемая ветка, вы можете ссылаться на нее с помощью `@{upstream}` или `@{u}` сокращенно. Итак, если вы находитесь на `master`-ветке, а отслеживается `origin/master`, вы можете вызвать что-то вроде `git merge @{u}` вместо `git merge origin/master` если хотите.(((+++@{u}+++)))(((+++@{upstream}+++)))
====

Если вы хотите посмотреть какие отслеживаемые ветки у вас установлены, вы можете воспользоваться опцией `-vv` в команде `git branch`. Отобразиться список ваших локальных веток с дополнительной информацией, включая то, какая из веток отслеживается, и если локальная ветка опережает, отстает или равняется относительно основной ветки.

[source,console]
----
$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new
----

Итак, здесь мы можем видеть, что наша `iss53`-ветка отслеживает `origin/iss53` и она опережает на два изменения, означающее, что мы имеем два локальных коммита, которые не отправлены на сервер. Мы может также увидеть, что наша `master`-ветка отслеживает `origin/master` и она в актуальном состоянии. Далее мы можем видеть, что наша `serverfix`-ветка отслеживает `server-fix-good`-ветку на нашем `teamone`-сервере и опережает на три коммита и отстает на один, означающее, что есть один коммит на сервере, который мы еще не слили и три локальных коммита, которые вы еще не отправили. В конце мы видим, что наша `testing`-ветка не отслеживает удаленную ветку.

Важно отметить, что эти цифры — только с каждого сервера, которые последний раз были извлечены. Эта команда не обращается к серверам, она говорит вам о том, что в кэше есть локальная информация с серверов. Если вы хотите полностью быть в курсе опережающих и отстающих коммитов, вам необходимо извлечь данные из всех ваших удаленных серверов перед запуском этой команды. Вы можете сделать нечто подобное: `$ git fetch --all; git branch -vv`

==== Получение изменений

(((pulling)))
Команда `git fetch` загрузит с сервера все изменения, которых у вас еще нет, но пока не будет изменять вашу рабочую директорию.
Эта команда просто получает данные для вас и позволяет вам самостоятельно сделать слияние.
Тем не менее, существует команда под названием `git pull`, которая является по существу командой `git fetch`, непосредственно за которой следует команда `git merge`, в большинстве случаев.
Если у вас есть отслеживаемая ветка как показано в предыдущем разделе, либо она явно установлена или она содержится вследствие создания вами командами `clone` или `checkout`, `git pull` увидит, что сервер и ветка вашей текущей ветки отслеживается, извлечет с сервера и затем попытается объединить в удаленную ветку.

Обычно лучше просто явно использовать команды `fetch` и `merge`, поскольку магия `git pull` может часто сбивать с толку.

[[_delete_branches]]
==== Удаление веток на удалённом сервере

(((branches, deleting remote)))
Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку `master` на удалённом сервере (или в какую-то другую ветку, где хранится стабильный код).
Вы можете удалить ветку на удалённом сервере, используя опцию `--delete` для `git push`.
Если вы хотите удалить ветку `serverfix` на сервере, выполните следующее:

[source,console]
----
$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix
----

В основном всё, что делает эта строка, — удаляет указатель на сервере. Как правило, Git-сервер оставит данные на некоторое время, пока не запустится сборщик мусора, итак, если ветка случайно была удалена, чаще всего ее легко восстановить.

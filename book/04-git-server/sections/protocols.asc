=== Протоколы

Git умеет работать с четырьмя сетевыми протоколами для передачи данных: локальный, HTTP, Secure Shell (SSH) и Git.
В этой части мы обсудим каждый из них и в каких случаях стоит (или не стоит) их использовать.

==== Локальный протокол

(((protocols, local)))
Базовым протоколом является _Локальный протокол_, при использовании которого удаленный репозиторий ― другой каталог на диске.
Наиболее часто он используется, если все члены команды имеют доступ к общей файловой системе, например к NFS, или, что менее вероятно, когда все работают на одном компьютере.
Последний вариант не столь хорош, поскольку все копии вашего репозитория находятся на одном компьютере, делая возможность потерять все более вероятной.

Если у вас смонтирована общая файловая система, вы можете клонировать, отправлять и получать изменения из локального репозитория.
Чтобы клонировать такой репозиторий или добавить его в качестве удаленного в существующий проект, используйте путь к репозиторию в качестве URL.
Например, для клонирования локального репозитория вы можете выполнить что-то вроде этого:

[source,console]
----
$ git clone /opt/git/project.git
----

Или этого:

[source,console]
----
$ git clone file:///opt/git/project.git
----

Git работает немного по-другому если вы явно укажете префикс `file://` в начале вашего URL.
Когда вы просто указываете путь, Git пытается использовать жесткие ссылки и копировать файлы, когда это нужно.
Если вы указываете `file://`, Git работает с данными так же как при использовании сетевых протоколов, что в целом менее эффективный способ передачи данных.
Причиной для использования `file://` может быть необходимость создания чистой копии репозитория без лишних внешних ссылок и объектов, обычно после импорта из другой СУВ или чего-то похожего (см. <<_git_internals>> о задачах поддержки).
Мы будем использовать обычные пути, поскольку это практически всегда быстрее.

Чтобы добавить локальный репозиторий в существующий проект, вы можете воспользоваться командой:

[source,console]
----
$ git remote add local_proj /opt/git/project.git
----

Теперь вы можете отправлять и получать изменения из этого репозитория так, как вы это делали по сети.

===== Достоинства

Преимущества основанных на файлах хранилищ в том, что они просты и используют существующие разграничения прав на файлы и сетевой доступ.
Если у вас уже есть общая файловая система, доступ к которой имеет вся команда, настройка репозитория очень проста.
Вы помещаете голый репозиторий туда, куда все имеют доступ, и выставляете права на чтение и запись, как вы бы это сделали для любого другого общего каталога.
Мы обсудим, как экспортировать голую копию репозитория для этой цели в следующем разделе, <<_git_on_the_server>>.

Также это хорошая возможность быстро получить наработки из чьего-то рабочего репозитория.
Если вы и ваш коллега работаете над одним и тем же проектом и он хочет, чтобы вы проверили что-то, то запуск команды вроде `git pull /home/john/project` зачастую проще, чем если бы он отправил на удалённый сервер, а вы забрали бы оттуда.

===== Недостатки

Недостаток этого метода в том, что общий доступ обычно сложнее настроить и получить из разных мест, чем простой сетевой доступ.
Если вы хотите отправлять со своего ноутбука, когда вы дома, вы должны смонтировать удалённый диск, что может быть сложно и медленно по сравнению с сетевым доступом.

Также важно упомянуть, что не всегда использование общей точки монтирования является быстрейшим вариантом.
Локальный репозиторий быстрый, только если вы имеете быстрый доступ к данным.
Репозиторий на NFS часто медленнее, чем репозиторий через SSH на том же сервере, позволяющий Git’у использовать на полную локальные диски на каждой системе.

==== Протоколы HTTP

Git может работать через HTTP в двух различных режимах.
До версии Git 1.6.6 был только один режим, очень простой и предназначенный только для чтения.
В версии 1.6.6 появился новый, более умный режим, позволяющий Git более интеллектуально определять необходимость передачи данных, наподобие того как это происходит при использовании SSH.
В последние годы новый протокол стал очень популярен, так как он проще для пользователя и более эффективен.
Новая версия часто называется ``Умным'' (``Smart'') HTTP, а старая ``Тупым'' (``Dump'') HTTP.
Мы рассмотрим сначала ``умный'' протокол.

===== Умный HTTP

(((protocols, smart HTTP)))
``Умный'' протокол HTTP работает схожим с SSH или Git-протоколами образом, но поверх стандартных HTTP/S портов и может использовать различные механизмы аутентификации HTTP, это часто проще для пользователя, чем что-то вроде SSH, так как можно использовать вещи вроде базовой парольной идентификации вместо установки SSH-ключей.

Он стал наверное наиболее популярным способом использования Git, так как может использоваться и для анонимного доступа, как протокол `git://`, и для отправки изменений с аутентификацией и шифрованием, как протокол SSH. Вместо использования разных адресов URL для этих вещей, можно использовать один для всего. Если вы пытаетесь отослать изменения и репозиторий требует аутентификации (обычно так и есть), сервер может спросить логин и пароль. То же касается и доступа на чтение.

На самом деле для сервисов вроде GitHub-а, адрес URL который вы используете для просмотра репозитория в браузере (например, ``https://github.com/schacon/simplegit[]'') - тот же, который вы можете использовать для клонирования или, если у вас есть доступ, для отправки изменений.

===== Тупой HTTP

(((protocols, dumb HTTP)))
Если сервер не отвечает на умный запрос Git по HTTP, клиент Git попытается откатиться на более простой ``тупой'' HTTP-протокол.
Тупой протокол ожидает, что голый репозиторий Git будет обслуживаться веб-сервером как набор файлов.
Прелесть тупого протокола HTTP - в простоте настройки.
По сути, всё, что необходимо сделать ― поместить голый репозиторий внутрь каталога с HTTP документами, установить обработчик `post-update` и всё (см. <<_git_hooks>>).
Теперь каждый, имеющий доступ к веб-серверу, на котором был размещен репозиторий, может его клонировать.
Таким образом, чтобы открыть доступ к вашему репозиторию на чтение через HTTP, нужно сделать что-то наподобие этого:

[source,console]
----
$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
----

Вот и всё.(((hooks, post-update)))
Обработчик `post-update`, входящий в состав Git по умолчанию, выполняет необходимую команду (`git update-server-info`), чтобы извлечение (fetch) и клонирование (clone) по HTTP работали правильно.
Эта команда выполняется, когда вы отправляете изменения в репозиторий (возможно посредством SSH); Затем остальные могут клонировать его командой

[source,console]
----
$ git clone https://example.com/gitproject.git
----

В рассмотренном примере, мы использовали каталог /var/www/htdocs, обычно используемый сервером Apache, но вы можете использовать любой веб-сервер, отдающий статические данные, расположив голый репозиторий в нужном каталоге.
Данные Git представляют собой обычные файлы (в <<_git_internals>> предоставление данных рассматривается более подробно).

Чаще всего вы будете использовать умный HTTP для чтения/записи или тупой только для чтения. Случай совместного их использования встречаются редко.

===== Достоинства

Мы сосредоточимся на преимуществах умной версии протокола HTTP.

Простота использования одного адреса URL для всех типов доступа и аутентификация только при необходимости делает работу очень простой для конечного пользователя.
Возможность аутентификации посредством логина и пароля также даёт преимущество перед SSH, так как пользователям не нужно создавать SSH-ключи и загружать публичную часть на сервер перед использованием.
Для неопытных пользователей или пользователей систем где SSH мало распространён, это большой плюс.
Это также очень быстрый и эффективный протокол, сравнимый с SSH.

Вы также можете раздавать доступ к своим репозиториям только для чтения по HTTPS, шифруя содержимое передачи; или вы можете зайти так далеко что клиенты будут использовать персональные подписанные SSL-сертификаты.

Другой плюс в том, что HTTP/S очень распространённые протоколы и корпоративные брандмауэры часто настроены для разрешения их работы.

===== Недостатки

На некоторых серверах Git поверх HTTP/S может быть немного сложнее в настройке по сравнению с SSH.
Кроме этого, преимущества других протоколов доступа к Git перед ``Умным'' HTTP незначительны.

Если вы используете HTTP для отправки изменений, удостоверение ваших полномочий зачастую более сложно чем при использовании SSH-ключей. Но есть несколько инструментов для кеширования полномочий, включая Keychain access на OSX и Credential Manager на Windows, которые вы можете использовать для упрощения процесса. В <<_credential_caching>> кеширование паролей HTTP рассматривается подробней.

==== Протокол SSH

(((protocols, SSH)))
Часто используемый транспортный протокол для хостинга Git — это SSH.
Причина этого в том, что доступ по SSH уже есть на многих серверах, а если его нет, то его очень легко настроить.
К тому же SSH протокол с аутентификацией, и благодаря его распространенности обычно его легко настроить и использовать.

Чтобы клонировать Git-репозиторий по SSH, вы можете указать префикс ssh:// в URL, например:

[source,console]
----
$ git clone ssh://user@server/project.git
----

Или вы можете использовать краткий синтаксис наподобие scp, для протокола SSH:

[source,console]
----
$ git clone user@server:project.git
----

Также вы можете не указывать имя пользователя, Git будет использовать то, под которым вы вошли в систему.

===== Достоинства

SSH имеет множество достоинств.
Во-первых, SSH достаточно легко настроить ― демоны SSH распространены, многие системные администраторы имеют опыт работы с ними, и во многих дистрибутивах они уже настроены или есть утилиты для управления ими.
Далее, доступ по SSH безопасен ― данные передаются зашифрованными по авторизованным каналам.
Наконец, так же как и протоколы HTTP/S, Git и локальный протокол, SSH эффективен, делая данные перед передачей максимально компактными.

===== Недостатки

Недостаток SSH в том, что, используя его, вы не можете обеспечить анонимный доступ к репозиторию.
Клиенты должны иметь доступ к машине по SSH, даже для работы в режиме только на чтение, что делает SSH неподходящим для проектов с открытым исходным кодом.
Если вы используете Git только внутри корпоративной сети, то возможно SSH единственный протокол, с которым вам придется иметь дело.
Если же вам нужен анонимный доступ на чтение для ваших проектов, вам придется настроить SSH для себя, чтобы выкладывать изменения, и что-нибудь другое для других, для скачивания.

==== Git-протокол

(((protocols, git)))
Следующий протокол ― Git-протокол.
Вместе с Git поставляется специальный демон, который слушает отдельный порт (9418) и предоставляет сервис, схожий с протоколом SSH, но абсолютно без аутентификации.
Чтобы использовать Git-протокол для репозитория, вы должны создать файл `git-export-daemon-ok`, иначе демон не будет работать с этим репозиторием, но следует помнить, что в протоколе отсутствуют средства безопасности.
Соответственно, любой репозиторий в Git может быть либо доступен для клонирования всем, либо нет.
Как следствие, обычно вы не можете отправлять изменения по этому протоколу.
Вы можете открыть доступ на запись, но из-за отсутствия аутентификации в этом случае кто угодно, зная URL вашего проекта, сможет его изменить.
В общем, это редко используемая возможность.

===== Достоинства

Git-протокол ― часто самый быстрый из доступных протоколов.
Если у вас проект с публичным доступом и большой трафик или у вас очень большой проект, для которого не требуется аутентификация пользователей для чтения, вам стоит настроить демон Git для вашего проекта.
Он использует тот же механизм передачи данных, что и протокол SSH, но без дополнительных затрат на шифрование и аутентификацию.

===== Недостатки

Недостатком Git-протокола является отсутствие аутентификации.
Поэтому обычно не следует использовать этот протокол как единственный способ доступа к вашему проекту.
Обычно он используется в паре с SSH или HTTPS для нескольких разработчиков, имеющих доступ на запись, тогда как все остальные используют `git://` с доступом только на чтение.
Кроме того, это, вероятно, самый сложный для настройки протокол.
Вы должны запустить собственно демон, для чего необходим сервис `xinetd` или ему подобный, что не всегда легко сделать.
Также необходимо, чтобы сетевой экран позволял доступ на порт 9418, который не является стандартным портом, всегда разрешённым в корпоративных брандмауэрах.
За сетевыми экранами крупных корпораций этот неизвестный порт часто заблокирован.

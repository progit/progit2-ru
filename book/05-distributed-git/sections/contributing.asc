[[r_contributing_project]]
=== Участие в проекте

(((contributing)))
Как именно участвовать в проекте - описать сложно, так как существует очень много различных вариаций как это делать.
Так как Git очень гибок, люди могут и работают вместе по разному. Отсюда и проблема описания участия в проекте - все проекты разные.
Переменными здесь являются: количество активных участников, выбранный рабочий процесс, права доступа и, возможно, метод организации внесения вклада в проект из вне.

Первая переменная - количество активных участников - подразумевает количество пользователей, котороые активно отправляют свой код в проект и как часто они это делают.
В большинстве случаев у вас два или три разработчика, которые делают по несколько коммитов в день или меньше, если речь идёт о вялотекущих проектах.
В больших компаниях или проектах количество разработчиков может исчисляться тысячами с сотнями тысяч коммитов в день.
Это очень важно, так как при увеличении количества разработчиков вы сталкиваетесь со всё большим количеством проблем, связанных со встраиванием или слиянием нового кода.
Изменения, которые вы отправляете, могут быть признаны устаревшимим или быть серьёзно затронутыми уже примененными изменениями, пока ваши ожидали одобрения.
Как в таком случае можно быть уверенным, что ваш код консистентен и актуален, а ваши коммиты валидны?

Следующая переменная - это используемый рабочий процесс.
Централизован ли рабочий процесс и обладают ли все разработчики одинаковыми правами на запись в основную ветку разработки?
Существует ли менеджер по интеграции или сопровождающий, кто провеяет все патчи?
Все ли патчи проверяются другими разработчиками и проходят одобрение?
Вы вовлечены в этот процесс?
Существует ли лейтенант, которому следует отправить изменения прежде, чем в основной репозиторий?

Следующая проблема - это уровень доступа.
Рабочий процесс, используемый для участия в проекте, может сильно отличаться в зависимости от того, есть ли у вас доступ на запись или нет.
Если у вас нет доступа на запись, то как проект принимает изменения?
Существуели ли вообще политика принятия изменений?
Как много изменений вы вносите за раз?
Как часто вы это делаете?

Все эти вопросы могут повлиять на эффективность вашего участия в проекте, а так же на то, какие рабочие процессы наиболее предпочтительны или доступны для вас.
Мы рассмотрим аспекты каждого из них на примере реальных ситуаций, переходя от более простых к более сложным. На основе этих примеров вы сможете создать реальные рабочие процессы применимые на практике.

[[r_commit_guidelines]]
==== Правила создания коммитов

Прежде чем мы начнём рассматривать конкретные варианты использования, давайте вспомним о сообщениях к коммитам.
Наличие четких рекомендаций по созданию коммитов и их соблюдение делают работу с Git и взаимодействие с другими гораздо проще.
Проект Git предоставляет документ, в котором содержится ряд полезных советов по созданию коммитов для отправки патчей - вы можете ознакомиться с ними, прочитав файл `Documentation/SubmittingPatches`, находящийся в исходных кодах Git.

(((git commands, diff, check)))
Для начала, вам не следует отправлять ненужные пробелы.
Git предоставляет простой способ проверки - перед коммитом выполните команду `git diff --check`, которая выведет список ненужных пробелов.

.Вывод команды `git diff --check`.
image::images/git-diff-check.png[Вывод команды `git diff --check`.]

выполняя эту команду перед коммитом вы сможете избежать отправки ненужных пробелов, которые могут раздражать других разработчиков.

Далее, постарайтесь делать коммит логически разделенного набора изменений.
Если возможно, попытайтесь делать ваши изменения легко понятными - не нужно писать код все выходные, работая над пятью разными задачами, а в понедельник отправлять результат как один большой коммит.
Даже если вы не делали коммиты на выходных, то в понедельник используйте область подготовленных файлов для того, чтобы разделить проделанную работу по принципу минимум один коммит на задачу, давая полезные коментарии к каждому из них.
Если несколько изменений касаются одного файла, используйте `git add --patch` для частичного добавления файлов в индекс (детально описано в <<ch07-git-tools#r_interactive_staging>>).
Состояние проекта в конце ветки не зависит от количества сделанных вами коммитов, так как все изменения добавятся в один момент, поэтому постарайтесь облегчить задачу вашим коллегам, когда они будут просматривать ваши изменения.
Такой подход так же облегчает ивлечение или отмену отдельных изменений, если это вдруг потребуется в будущем.
<<ch07-git-tools#r_rewriting_history>> описывает ряд полезных трюков Git для переписывания истории изменений и интерактивного инексирования - используйте эти инструменты для создания чистой и понятной истории перед отправкой проделанной работы кому-то ещё.

Последнее, что нужно иметь ввиду - это сообщение коммита.
Привычка создавать качественные сообщения к коммитам позволяет упростить использование и взаимодействие по средствам Git.
Как правило, ваши сообщения должны начинаться кратким однострочным описанием не более 50 символов, затем должна идти пустая строка, после которой следует более детальное описание.
Проект Git требует, чтобы детальное описание включало вашу мотивацию при внесении изменения и сравнение с текущей реализацией - это хороший пример для подражания.
Так же хорошей идеей будет использование фраз в повелительном наклонении настоящего времени.
Другими словами - используйте команды.
Вместо ``Я добавил тесты для'' или ``Добавление тестов для'', используйте ``Добавить тесты для''.
Ниже представлен шаблон, написанный Tim Pope:

[source,text]
-----
Краткое (50 символов или меньше) описание изменений

Текст более детального описания, если необходим. Старайтесь
не первышать длинну строки в 72 символа. В некоторых случаях
первая строка подразумевается как тема письма, а всё остальное - 
тело письма. Пустая строка, разделяющая сообщение, критически важна
(если существует детальное описание); такие утилиты как rebase
могут запутаться, если вы запустите сразу две.

Последующие параграфы должны отделяться пустыми строками.

  - Списки тоже подходят

  - Обычно, элементы списка обозначаются с помощью тире или звёздочки,
    предваряются одиночным пробелом, а разделяются пустой строкой, но
    соглашения могут отличаться
-----

Вам и вашим разработчикам будет гораздо проще, если все сообщения ваших коммитов будут так выглядеть.
В проекте Git все сообщения хорошо отформатированы - выполните команду `git log --no-merges`, чтобы увидеть как выглядит хорошо отформатированная история коммитов.

В последующих примерах, как и практически везде в этой книге, для краткости не используется расширенное форматирование; вместо этого используется опция `-m` команды `git commit`.
Делайте как мы говорим, а не так как делаем мы.

[[r_private_team]]
==== Частная небольшая команда
==== Private Small Team

(((contributing, private small team)))
Самоя простая ситуация, с которой вы можете столкнуться, это приватный проект с одинм или двумя другими разработчиками.
``Частная'' - в данном контесте понимается как проект с закрытым исходным кодом, недоступный для внешнего мира. Вы и другие разработчики имеете права записи в репозиторий.

В такой среде вы можете использовать рабочий процесс, при котором выполняемые действия анологичны использованию Subversion или другой централизованной системе.
Вы всё ещё можете использовать преимущества создания коммитов оффлайн, значительно более простое ветвление и слияние, но процесс будет очень похожим; основное отличие в том, что слияние происходит на стороне клиента, а не на сервере во время коммита.
Давайте посмотрим что происходит, когда два разработчика начинают работать вместе и используют общий репозиторий.
Первый разработчик Джон клонирует репозиторий, вносит изменения и делает коммит локально.
(В последующих примерах сообщения протокола заменены на `...` с целью их немного сократить.)

[source,console]
-----
# Компьютер Джона
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

Второй разработчик Джессика делает тоже самое - клонирует репозиторий и делает коммит:

[source,console]
-----
# Компьютер Джессики
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

Затем Джессика отправляет изменения на сервер:

[source,console]
-----
# Компьютер Джессики
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
-----

Джон так же пытается отправить свои изменения:

[source,console]
-----
# Компьютер Джона
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
-----

Джону запрещено отправлять изменения, так как Джессика уже отправила свои.
Это особенно важно для понимания, особенно если вы привыкли к Subversion, потому что, как вы могли заметить, разработчики не редактировали один и тот же файл.
Если Subversion автоматически делает слияние на сервере при условии, что редактировались разные файлы, то в Git вы должны слить изменения локально.
Джон должен получить изменения Джессики и слить их локально, прежде чем сможет отправить свои:

[source,console]
-----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
-----

В этот момент локальный репозиторий Джона выглядит примерно так:

.Расходящаяся история Джона.
image::images/small-team-1.png[Расходящаяся история Джона.]

У Джона есть ссылка на отправленные Джессикой изменения, но он должен применить их к своей работе прежде, чем сможет отправить свои:

[source,console]
-----
$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

Процесс слияния проходит гладко - история коммитов у Джона выглядит примерно так:

.Репозиторий Джона после слияния с `origin/master`.
image::images/small-team-2.png[Репозиторий Джона после слияния с `origin/master`.]

Теперь Джон может протестировать свой код, чтобы убедиться в корректной работе своих изменений, после чего он может отправить объединенную работу на сервер:

[source,console]
-----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
-----

В результате история коммитов у Джона выглядит так:

.История коммитов у Джона после отправки на `origin` сервер.
image::images/small-team-3.png[История коммитов у Джона после отправки на `origin` сервер.]

Тем временем Джессика продолжала работать в тематической ветке под названием `issue54` и сделала три коммита в ней.
Она ещё не получила изменения Джона, поэтому история коммитов у неё выглядит следующим образом:

.Тематическая ветка Джессики.
image::images/small-team-4.png[Тематическая ветка Джессики.]

Для синхронизации с Джоном Джессика получает изменения:

[source,console]
-----
# Компьютер Джессики
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
-----

Это приводит к получению изменений, отправленных Джоном в репозиторий.
Теперь, история коммитов у Джессики выглядит так:

.История коммитов Джессики после получения изменений Джона.
image::images/small-team-5.png[История коммитов Джессики после получения изменений Джона.]

Джессика считает, что её тематическая ветка готова, но так же хочет знать какие изменения следует слить со своей работой перед отправкой на сервер.
Для прояснения ситуации он выполняет команду `git log`:

[source,console]
-----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value
-----

`issue54..origin/master` - это синтаксис фильтра, который указывает Git отображать только список коммитов, которые существуют в последней ветке (в данном случае `origin/master`), но отсутствуют в первой (в данном случае `issue54`). Более детально этот синтаксис рассматривается в главе <<ch07-git-tools#r_commit_ranges>>.

В данном случае, в выводе команды мы видим только один коммит, сделанный Джоном и ещё не слитый Джессикой. Если она сольёт `origin/master`, то это будет единственный коммит, который изменит локальное состояние.

Теперь, Джессика может слить изменения тематической ветки и изменения Джона (`origin/master`) в свою локальную ветку `master`, а затем отправить её на сервер.
Для начала, следует переключиться на ветку `master` и слить изменения тематической ветки:

[source,console]
-----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
-----

Обе ветки `origin/master` и `issue54` являются отслеживаемыми, поэтому порядок слияния не важен.
Конечный результат будет идентичным вне зависимости от порядка слияния, однако история коммитов будет немного отличаться.
Джессика решает слить ветку `issue54` первой:

[source,console]
-----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
-----

Проблем не возникает; как можно заметить, это простое перемещение вперед.
Теперь Джессика сливает изменения Джона (`origin/master`):

[source,console]
-----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

Слияние прошло чисто и теперь история коммитов у Джессики выглядит следующим образом:

.История коммитов Джессики после слияния изменений Джона.
image::images/small-team-6.png[История коммитов Джессики после слияния изменений Джона.]

Теперь Джессика может отправить свою ветку `master` в `origin/master`, при условии что Джон больше не отправлял изменений:

[source,console]
-----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
-----

Каждый разработчик сделал коммиты несколько раз и успешно слил изменения другого.

.История коммитов Джессики после отправки на сервер.
image::images/small-team-7.png[История коммитов Джессики после отправки на сервер.]

Это один из самых простых рабочих процессов.
В течение некоторого времени вы работаете в тематической ветке, а затем сливаете изменения в ветку `master` когда всё готово.
Чтобы поделиться проделанной работой, вы сливаете её в вашу ветку `master`, затем получаете и сливаете изменения из ветки `origin/master` если таковые имеются, и наконец, отправляете все изменения в ветку `master` на сервере.
В общем виде последовательность выглядит так:

.Общий вид последовательности событий в рабочем процессе для нескольких разработчиков.
image::images/small-team-flow.png[Общий вид последовательности событий в рабочем процессе для нескольких разработчиков.]

==== Private Managed Team

(((contributing, private managed team)))
In this next scenario, you'll look at contributor roles in a larger private group.
You'll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.

Let's say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second.
In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the `master` branch of the main repo can be updated only by those engineers.
In this scenario, all work is done in team-based branches and pulled together by the integrators later.

Let's follow Jessica's workflow as she works on her two features, collaborating in parallel with two different developers in this environment.
Assuming she already has her repository cloned, she decides to work on `featureA` first.
She creates a new branch for the feature and does some work on it there:

[source,console]
-----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

At this point, she needs to share her work with John, so she pushes her `featureA` branch commits up to the server.
Jessica doesn't have push access to the `master` branch – only the integrators do – so she has to push to another branch in order to collaborate with John:

[source,console]
-----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
-----

Jessica e-mails John to tell him that she's pushed some work into a branch named `featureA` and he can look at it now.
While she waits for feedback from John, Jessica decides to start working on `featureB` with Josie.
To begin, she starts a new feature branch, basing it off the server's `master` branch:

[source,console]
-----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
-----

Now, Jessica makes a couple of commits on the `featureB` branch:

[source,console]
-----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
-----

Jessica's repository looks like this:

.Jessica's initial commit history.
image::images/managed-team-1.png[Jessica's initial commit history.]

She's ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as `featureBee`.
Jessica first needs to merge those changes in with her own before she can push to the server.
She can then fetch Josie's changes down with `git fetch`:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
-----

Jessica can now merge this into the work she did with `git merge`:

[source,console]
-----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
-----

There is a bit of a problem – she needs to push the merged work in her `featureB` branch to the `featureBee` branch on the server.
She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the `git push` command:

[source,console]
-----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
-----

This is called a _refspec_.
See <<ch10-git-internals#r_refspec>> for a more detailed discussion of Git refspecs and different things you can do with them.
Also notice the `-u` flag; this is short for `--set-upstream`, which configures the branches for easier pushing and pulling later.

Next, John e-mails Jessica to say he's pushed some changes to the `featureA` branch and asks her to verify them.
She runs a `git fetch` to pull down those changes:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
-----

Then, she can see what has been changed with `git log`:

[source,console]
-----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
-----

Finally, she merges John's work into her own `featureA` branch:

[source,console]
-----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
-----

Jessica wants to tweak something, so she commits again and then pushes this back up to the server:

[source,console]
-----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
-----

Jessica's commit history now looks something like this:

.Jessica's history after committing on a feature branch.
image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]

Jessica, Josie, and John inform the integrators that the `featureA` and `featureBee` branches on the server are ready for integration into the mainline.
After the integrators merge these branches into the mainline, a fetch will bring down the new merge commit, making the history look like this:

.Jessica's history after merging both her topic branches.
image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]

Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process.
The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git.
The sequence for the workflow you saw here is something like this:

.Basic sequence of this managed-team workflow.
image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]

[[r_public_project]]
==== Forked Public Project

(((contributing, public small project)))
Contributing to public projects is a bit different.
Because you don't have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
This first example describes contributing via forking on Git hosts that support easy forking.
Many hosting sites support this (including GitHub, BitBucket, Google Code, repo.or.cz, and others), and many project maintainers expect this style of contribution.
The next section deals with projects that prefer to accept contributed patches via e-mail.

First, you'll probably want to clone the main repository, create a topic branch for the patch or patch series you're planning to contribute, and do your work there.
The sequence looks basically like this:

[source,console]
-----
$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
-----

[NOTE]
====
You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review – see <<ch07-git-tools#r_rewriting_history>> for more information about interactive rebasing.
====

When your branch work is finished and you're ready to contribute it back to the maintainers, go to the original project page and click the ``Fork'' button, creating your own writable fork of the project.
You then need to add in this new repository URL as a second remote, in this case named `myfork`:

[source,console]
-----
$ git remote add myfork (url)
-----

Then you need to push your work up to it.
It's easiest to push the topic branch you're working on up to your repository, rather than merging into your master branch and pushing that up.
The reason is that if the work isn't accepted or is cherry picked, you don't have to rewind your master branch.
If the maintainers merge, rebase, or cherry-pick your work, you'll eventually get it back via pulling from their repository anyhow:

[source,console]
-----
$ git push -u myfork featureA
-----

(((git commands, request-pull)))
When your work has been pushed up to your fork, you need to notify the maintainer.
This is often called a pull request, and you can either generate it via the website – GitHub has its own Pull Request mechanism that we'll go over in <<ch06-github#ch06-github>> – or you can run the `git request-pull` command and e-mail the output to the project maintainer manually.

The `request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you're asking to be pulled in.
For instance, if Jessica wants to send John a pull request, and she's done two commits on the topic branch she just pushed up, she can run this:

[source,console]
-----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
-----

The output can be sent to the maintainer–it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.

On a project for which you're not the maintainer, it's generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they're rejected.
Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.
For example, if you want to submit a second topic of work to the project, don't continue working on the topic branch you just pushed up – start over from the main repository's `master` branch:

[source,console]
-----
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
# (email maintainer)
$ git fetch origin
-----

Now, each of your topics is contained within a silo – similar to a patch queue – that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:

.Initial commit history with `featureB` work.
image::images/public-small-1.png[Initial commit history with `featureB` work.]

Let's say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
In this case, you can try to rebase that branch on top of `origin/master`, resolve the conflicts for the maintainer, and then resubmit your changes:

[source,console]
-----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
-----

This rewrites your history to now look like <<rpsp_b>>.

[[rpsp_b]]
.Commit history after `featureA` work.
image::images/public-small-2.png[Commit history after `featureA` work.]

Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn't a descendant of it.
An alternative would be to push this new work to a different branch on the server (perhaps called `featureAv2`).

Let's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
You'll also take this opportunity to move the work to be based off the project's current `master` branch.
You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:

(((git commands, merge, squash)))
[source,console]
-----
$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
-----

The `--squash` option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you're on.
The `--no-commit` option tells Git not to automatically record a commit.
This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.

Now you can send the maintainer a message that you've made the requested changes and they can find those changes in your `featureBv2` branch.

.Commit history after `featureBv2` work.
image::images/public-small-3.png[Commit history after `featureBv2` work.]

[[r_project_over_email]]
==== Public Project over E-Mail

(((contributing, public large project)))
Many projects have established procedures for accepting patches – you'll need to check the specific rules for each project, because they will differ.
Since there are several older, larger projects which accept patches via a developer mailing list, we'll go over an example of that now.

The workflow is similar to the previous use case – you create topic branches for each patch series you work on.
The difference is how you submit them to the project.
Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:

[source,console]
-----
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
-----

(((git commands, format-patch)))
Now you have two commits that you want to send to the mailing list.
You use `git format-patch` to generate the mbox-formatted files that you can e-mail to the list – it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an e-mail generated with `format-patch` preserves all the commit information properly.

[source,console]
-----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
-----

The `format-patch` command prints out the names of the patch files it creates.
The `-M` switch tells Git to look for renames.
The files end up looking like this:

[source,console]
-----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
-----

You can also edit these patch files to add more information for the e-mail list that you don't want to show up in the commit message.
If you add text between the `---` line and the beginning of the patch (the `diff --git` line), then developers can read it; but applying the patch excludes it.

To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with ``smarter'' clients that don't preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.
We'll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.

(((git commands, config)))(((email)))
First, you need to set up the imap section in your `~/.gitconfig` file.
You can set each value separately with a series of `git config` commands, or you can add them manually, but in the end your config file should look something like this:

[source,ini]
-----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
-----

If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
When that is set up, you can use `git send-email` to place the patch series in the Drafts folder of the specified IMAP server:

[source,console]
-----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
-----

Then, Git spits out a bunch of log information looking something like this for each patch you're sending:

[source,text]
-----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
-----

At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.

==== Summary

This section has covered a number of common workflows for dealing with several very different types of Git projects you're likely to encounter, and introduced a couple of new tools to help you manage this process.
Next, you'll see how to work the other side of the coin: maintaining a Git project.
You'll learn how to be a benevolent dictator or integration manager.

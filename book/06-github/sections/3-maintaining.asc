[[r_maintaining_gh_project]]
=== Сопровождение проекта

Теперь, когда вы комфортно себя чувствуете при участии в проекте, давайте посмотрим на другую сторону вопроса: создание, сопровождение и адимнистрирование вашего собственного проекта.

==== Создание нового репозитория

Давайте создадим новый репозиторий для распространения кода нашего проекта.
В панели управления справа нажмите кнопку ``New repository'' или воспользуйтесь кнопкой `+` на панели инструментов, рядом с вашим именем пользователя как показано на рисунке <<r_new_repo_dropdown>>.

.Раздел ``Your repositories''
image::images/newrepo.png[Раздел ``Your repositories''.]

[[r_new_repo_dropdown]]
.Выпадающее меню ``New repository''.
image::images/new-repo.png[Выпадающее меню ``New repository''.]

Это приведет к открытию формы ``new repository'':

.Форма ``new repository''
image::images/newrepoform.png[Форма ``new repository''.]

Всё, что в действительности нужно сделать, так это указать название проекта, все остальные поля опциональны.
Сейчас, просто нажмите кнопку ``Create Repository'' и ваш новый репозиторий с названием `<пользователь>/<имя_проекта>` готов.

Так как в репозитории ещё нет кода, GitHub отобразит инструкции о том как создать совершенно новый репозиторий или подключить существующий Git проект.
Здесь мы не будем этого делать; если вам нужно освежить память, воспользуйтесь <<ch02-git-basics#ch02-git-basics>>.

Теперь ваш проект хостится на GitHub и вы можете предоставить ссылку на него любому желающему.
Все проекты на GitHub доступны как по HTTP `https://github.com/<пользователь>/<имя_проекта>`, так  по SSH `git@github.com:<пользователь>/<имя_проекта>`.
Git может получать и отправлять изменения по обоим указанным ссылкам, при этом производится контроль доступа на основании учётных данных пользователя, осуществляющего подключение.

[NOTE]
====
Обычно, для общедоступного проекта предпочтительнее использовать HTTP ссылки, так как это не требует наличия GitHub аккаунта для клонирования репозитория.
При этом, для использования SSH ссылки у пользователя должен быть GitHub аккаунт и его SSH ключ должен быть добавлен в ваш проект. Так же HTTP ссылка полностью совпадает с URL адресом, который пользователи могут вставить в браузер для просмотра вашего репозитория.
====

==== Добавление участников

Если вы работаете с другими людьми, которым вы хотите предоставить доступ для отправки коммитов, то вам следует добаить их как ``участников''.
Если Бен, Джефф и Льюис зарегистрировались на GitHub и вы хотите разрешить им делать ``push'' в ваш репозиторий, то добавьте их в свой проект.
Это предоставит им ``push'' доступ; это означает, что они будут иметь права доступа как на чтение, так и на запись в проект и Git репозиторй.

Перейдите по ссылке ``Settings'' в нижней части панели справа.

.Ссылка на настройки репозитория
image::images/reposettingslink.png[Ссылка на настройки репозитория.]

Затем выберите ``Collaborators'' в меню слева.
Напишите имя пользователя в поле для ввода и нажмите кнопку ``Add collaborator''.
Так вы можете добавить неограниченное количество пользователей.
Чтобы отозвать доступ, просто нажмите ``X'' справа от имени пользователя.

.Участники проекта
image::images/collaborators.png[Окно участников проекта]

==== Управление запросами на слияние

Сейчас у вас есть проект с некоторым кодом и, возможно, несколько участников с ``push'' доступом, давайте рассмотрим ситуацию, когда вы получается запрос на слияние.

Запрос на слияние может быть как из ветки вашего репозитория, так и из ветки форка вашего проекта. Отличаются они тем, что вы не можете отправлять изменения в ветки ответвленного проекта, а его владелцы не могут отправлять в ваши, при этом для внутренних запросов на слияние характерно наличие доступа к ветке у обоих пользователей.

Для последующих примеров предположим, что вы ``tonychacon'' и создали новый проект для Arudino c с названием ``fade''.

[[r_email_notifications]]
===== Email уведомления

Кто-то вносит изменения в ваш код и отправляет вам запрос на слияние. Вы должны получить письмо с уведомлением о новом запросе слияния, которое выглядит как на <<r_email_pr>>.

[[r_email_pr]]
.Email уведомление о новом запросе слияния
image::images/maint-01-email.png[Email уведомление о запросе слияния.]

Следует сказать о некоторых особенностях этого уведомления. В нем содержится краткая статистика отличий -- количество изменений и список файлов, которые были изменены в этом запросе слияния, ссылка на страницу запроса слияния на GitHub, а так же несколько ссылок, которые вы можете использовать в командной строке.

Если вы видите строку с текстом `git pull <url> patch-1`, то это самый простой способ слить удаленную ветку без добавления удаленного репозитория. Это кратко писывалось в <<ch05-distributed-git#r_checking_out_remotes>>. Если хотите, то можно сначала переключиться в тематическую ветку и только потом выполнить эту команду для изменений запроса слияния.

Другие ссылки, которые представляют интерес, это `.diff` и `.patch` ссылки. Как вы догадались, они указывают на версии унифицированной разницы и патча запроса слияния. Технически, вы можете слить изменения из запроса слияния командой:

[source,console]
----
$ curl http://github.com/tonychacon/fade/pull/1.patch | git am
----

===== Взаимодействие по запросу слияния

Как описано в <<r_github_flow>>, вы можете общаться с тем, кто открыл запрос на слияние. Вы можете добавлять коментари к отдельным строкам кода, коммитам или ко всем зупросу целиком, используя усовершенствованную разметку GitHub где угодно.

Каждый раз, когда кто-то другой оставляет коментарий к запросу слияния, вы будет получать email уведомления по каждому событию. Какждое уведомление будет содержать ссылку на страницу запроса слияния, где была зафиксирована активность, и вы можете просто ответить на это письмо, чтобы оставить коментарий в основной ветке запроса на слияние.

.Ответы на письма включены в диалог
image::images/maint-03-email-resp.png[Email ответ]

Когда вы готовы слить код, вы можете или стянув его себе слить локально, или слить используя команду `git pull <url> <branch>`, которую мы видели ранее, или получить и слить изменения, добавив ответвленный репозиторий как удаленный.

Если слияние тривиально, то можно просто нажать кнопку ``Merge'' на сайте GitHub. Это всегда приводит с созданию коммита слияния, даже если доступно слияние перемоткой вперед. Это значит, что в любом случае создаётся коммит слияния, как только вы нажимаете кнопку ``Merge''. Как можно увидеть на <<r_merge_button>>, GitHub отображает информацию об этом при вызове подсказки.

[[r_merge_button]]
.Кнопка Merge и инструкции по ручному слиянию запроса
image::images/maint-02-merge.png[Кнопка Merge]

Если вы решаете не сливать запрос, то вы можете просто закрыть запрос на слияние, а открывший его участник будет уведомлен.

[[r_pr_refs]]
===== Pull Request Refs

Если у вас *много* запросов слияния и вы не хотите добавлять пачку удаленных репозиториев или постоянно делать однократный ``pull'', то у GitHub есть хитрый трюк, позволяющий это делать. Этот трюк очень сложный, но полезный и мы рассмотрим его немного позже в <<ch10-git-internals#r_refspec>>.

Фактически, GitHub представляет ветки запросов слияния как псевдо ветки на сервере. По умолчанию, они не копируются при клонировании, а существуют в замаскированном виде и вы можете легко получить доступ к ним.

В качестве примера мы используем низкоуровневую команду `ls-remote` (часто упоминается как ``plumbing'' команда, более подробно о ней будет рассказано в <<ch10-git-internals#r_plumbing_porcelain>>). Обычно, эта команда не используется в повседневных Git операциях, но сейчас поможет нам увидеть какие ссылки присутствуют на сервере.

Если выполнить её относительно использованного ранее репозитория ``blink'', мы получим список всех веток, тэгов и прочих ссылок в репозитории.

[source,console]
----
$ git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge
----

Аналогично, если вы, находясь в своём репозитории, выполните команду `git ls-remote origin` или укажете любой другой удаленный репозиторий, то результат будет схожим.

Если репозиторий находится на GitHub и существуют открытые запросы слияния, то эти ссылки будут отображены с префиксами `refs/pull/`.
По сути это ветки, но так как они находятся не в `refs/heads/`, то они не копируются при клонировании или получении измененй с сервера -- процесс получения изменений игнорирует их по умолчанию.

Для каждого запроса слияния существует две ссылки, одна из которых записана в `/head` и указывает на последний коммит в ветке запроса на слияние.
Таким образом, если кто-то открывает запрос на слияние в наш репозиторий из своей ветки `bug-fix`, которая указывает на коммит `a5a775`, то в *нашем* репозитории не будет ветки `bug-fix` (так как она находится в форке), при этом у нас _появится_ `pull/<pr#>/head`, которая указывает на `a5a775`. Это означает, что мы можем стянуть все ветки запросов слияния одной командой не добавляя набор удаленных репозиториев.

Теперь можно получить ссылки напрямую.

[source,console]
----
$ git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -> FETCH_HEAD
----

Эта команда указывает Git: ``Подключись к `origin` репозиторию и скачай ссылку `refs/pull/958/head`''.
Git с радостью слушается и выкачивает всё необходимое для построения указанной ссылки, а так же устанавливает указатель на коммит в `.git/FETCH_HEAD`.
Далее, вы можете слить изменения в нужную ветку при помощи команды `git merge FETCH_HEAD`, однако сообщение коммита слияния будет выглядеть немного странно.
Так же это становится утомительным, если вы просматриваете *много* запросов на слияние.

Существует способ получать _все_ запросы слияния и поддерживать их в актуальном состоянии при подключении к удаленному репозиторию.
Откройте файл `.git/config` в текстовом редакторе и обратите внимание на секцию удаленного репозитория `origin`.
Она должна выглядеть как-то так:

----
[remote "origin"]
    url = https://github.com/libgit2/libgit2
    fetch = +refs/heads/*:refs/remotes/origin/*
----

Строка, начинающаяся с `fetch =`, является спецификацией ссылок (``refspec'').
Это способ сопоставить названия в удаленном репозитории и названиями в локальной папке `.git`.
Конкретно эта строка говорит Git: "все объекты удаленного репозитория из `refs/heads` должны сохраняться в локально в `refs/remotes/origin`".
Вы можете изменить это поведения добавив ещё одну строку спецификации:

----
[remote "origin"]
    url = https://github.com/libgit2/libgit2.git
    fetch = +refs/heads/*:refs/remotes/origin/*
    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
----

Последняя строка говорит Git: "Все ссылки, похожие на `refs/pull/123/head`, должны быть сохранены локально как `refs/remotes/origin/pr/123`".
Теперь, если сохранить файл и выолнить команду `git fetch`, вы получите:

[source,console]
----
$ git fetch
# …
 * [new ref]         refs/pull/1/head -> origin/pr/1
 * [new ref]         refs/pull/2/head -> origin/pr/2
 * [new ref]         refs/pull/4/head -> origin/pr/4
# …
----

Все запросы слияния из удаленного репозитория представлены в локальном репозитории как ветки слежения; они только для чтения и обновляются каждый раз при выполнении `git fetch`.
Таким образом, локальное тестирование кода запроса слияния становится очень простым:

[source,console]
----
$ git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch 'pr/2'
----

Особо внимательные из вас заметили `head` в конце спецификации, относящейся к удаленному репозиторию.
Так же на стороне GitHub существует ссылка `refs/pull/#/merge`, которая представляет коммит, формируемый при нажатии кнопки ``merge'' на сайте.
Это позволяет вам протестировать слияние перед нажатием этой кнопки.

===== Запросы слияния на запросы слияния
===== Pull Requests on Pull Requests

Вы можете открыть запрос слияния не только в ветку `master`, запросы слияния могут указывать на любую ветку любого репозитория в сети. По сути, вы можете даже открыть запрос слияния, указывающий на другой запрос слияния.

Если вы видите толковый запрос слияния и у вас есть идея как его улучшить или вы не уверены, что это хорошая идея, или у вас просто нет прав записи в целевую ветку, то в таком случае вы можете открыть запрос слияния, указывающий на данный запрос.

При открытии запроса на слияние вверху страницы вы увидите меню для выбора целевой и исходной веток. Если нажать кнопку `Edit'' справа, то станет доступным выбор не только исходной ветки, а ещё и форка.

[[r_pr_targets]]
.Ручное изменение форка и ветки для запроса слияния
image::images/maint-04-target.png[Объекты запроса слияния]

Здесь можно указать вашу новую ветку для слияния с другим запросом слияния или другим форком проекта.

==== Упоминания и уведомления

GitHub обладает отличной встроенной системой уведомлений, которая может пригодиться для решения вопросов или получения обратной связи от конкретных людей или команд.

В любом коментарии можно написать символ `@`, что автоматически вызвет список автодополнения с именами пользователей, которые включены в проект или просто участвуют в нём.

.Напишите @ для упоминания кого-либо
image::images/maint-05-mentions.png[Упоминания]

Так же можно упомянуть пользователя, не указанного в выпадающем списке, но с помощью автодополнения это можно сделать быстрее.

Как только вы оставить коментарий с упоминанием пользователя, ему будет отправлено уведомление. Таким образом, можно более эффективно вовлекать пользователей в обсуждение, не опрашивая их непосредственно. Очань часто в запросах слияния на GitHub пользователи приглашают других людей в свои команды или компании для рецензии проблем или запросов слияния.

Если кто-то будет упомянут в запросе слияния или проблеме, то он автоматически ``подписывается'' и будет получать уведомления о последующей активности. Вы так же будете подписаны на некоторые уведомления если просто откроете запрос слияния или проблему, станете отслеживать репозиторий или если оставите коментарий. Для прекращения отправки вам уведомлений нажмите кнопку ``Unsubscribe''.


.Отказ от подписки на проблему или запрос слияния
image::images/maint-06-unsubscribe.png[Отказ от подписки]

===== Страница уведомлений

Когда мы говорим ``уведомления'' в контексте GitHub, мы имеем ввиду способ, которым GitHub пытается связаться с вами в случае возникновения каких-либо событий, настроить который можно несколькими способами.
Для просмотра настроек уведомлений перейдите на закладку ``Notification center'' на странице настроек.

.Настройки центра уведомлений
image::images/maint-07-notifications.png[Центр уведомлений]

Доступны два вида уведомлений: пос средствам ``Email'' и ``Web''. Вы можете выбрать один, ни одного или оба, если активно участвуете в событиях отслеживаемых репозиториев.

====== Web уведомления

Такие уведомления существуют только на GitHub и посмотреть их можно только на GitHub. Если эта опция включена у вас в настройках и уведомление сработало для вас, то вы увидите небольшую синию точку на иконке уведомлений вверху экрана, как показано на рисунке <<r_not_center>>.

[[r_not_center]]
.Центр уведомлений
image::images/maint-08-notifications-page.png[Центр уведомлений]

Кликнув по иконке, вы увидите список всех уведомлений, сгруппированных по проектам. Вы можете фильтровать уведомления по конкретному проекту, кликнув по его названию на боковой панели слева. Так же вы можете подтверждать получение уведомлений, кликнув по галочке рядом с любым из уведомлений, или подтвердить _все_ уведомления по проекту, кликнув по галочке в шапке группы. После каждой галочки так же есть кнопка отключения, кликнув по которой вы перестанете получать уведомления по данному элементу.

Эти инструменты очень полезны при обработке большого числа уведомлений. Продвинутые пользователи GitHub полностью отключают email уведомления и пользуются этой страницей.

====== Email уведомления

Email notifications are the other way you can handle notifications through GitHub. If you have this turned on you will get emails for each notification. We saw examples of this in <<r_email_notification>> and <<r_email_pr>>. The emails will also be threaded properly, which is nice if you're using a threading email client.

There is also a fair amount of metadata embedded in the headers of the emails that GitHub sends you, which can be really helpful for setting up custom filters and rules.

For instance, if we look at the actual email headers sent to Tony in the email shown in <<r_email_pr>>, we will see the following among the information sent:

[source,mbox]
----
To: tonychacon/fade <fade@noreply.github.com>
Message-ID: <tonychacon/fade/pull/1@github.com>
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade <fade.tonychacon.github.com>
List-Archive: https://github.com/tonychacon/fade
List-Post: <mailto:reply+i-4XXX@reply.github.com>
List-Unsubscribe: <mailto:unsub+i-XXX@reply.github.com>,...
X-GitHub-Recipient-Address: tchacon@example.com
----

There are a couple of interesting things here. If you want to highlight or re-route emails to this particular project or even Pull Request, the information in `Message-ID` gives you all the data in `<user>/<project>/<type>/<id>` format. If this were an issue, for example, the `<type>` field would have been ``issues'' rather than ``pull''.

The `List-Post` and `List-Unsubscribe` fields mean that if you have a mail client that understands those, you can easily post to the list or ``Unsubscribe'' from the thread. That would be essentially the same as clicking the ``mute'' button on the web version of the notification or ``Unsubscribe'' on the Issue or Pull Request page itself.

It's also worth noting that if you have both email and web notifications enabled and you read the email version of the notification, the web version will be marked as read as well if you have images allowed in your mail client.

==== Special Files

There are a couple of special files that GitHub will notice if they are present in your repository.

==== README

The first is the `README` file, which can be of nearly any format that GitHub recognizes as prose. For example, it could be `README`, `README.md`, `README.asciidoc`, etc. If GitHub sees a README file in your source, it will render it on the landing page of the project.

Many teams use this file to hold all the relevant project information for someone who might be new to the repository or project. This generally includes things like:

* What the project is for
* How to configure and install it
* An example of how to use it or get it running
* The license that the project is offered under
* How to contribute to it

Since GitHub will render this file, you can embed images or links in it for added ease of understanding.

==== CONTRIBUTING

The other special file that GitHub recognizes is the `CONTRIBUTING` file. If you have a file named `CONTRIBUTING` with any file extension, GitHub will show <<r_contrib_file>> when anyone starts opening a Pull Request.

[[r_contrib_file]]
.Opening a Pull Request when a CONTRIBUTING file exists.
image::images/maint-09-contrib.png[Contributing notice]

The idea here is that you can specify specific things you want or don't want in a Pull Request sent to your project. This way people may actually read the guidelines before opening the Pull Request.

==== Project Administration

Generally there are not a lot of administrative things you can do with a single project, but there are a couple of items that might be of interest.

===== Changing the Default Branch

If you are using a branch other than ``master'' as your default branch that you want people to open Pull Requests on or see by default, you can change that in your repository's settings page under the ``Options'' tab.

[[r_default_branch]]
.Change the default branch for a project.
image::images/maint-10-default-branch.png[Default branch]

Simply change the default branch in the dropdown and that will be the default for all major operations from then on, including which branch is checked out by default when someone clones the repository.

===== Transferring a Project

If you would like to transfer a project to another user or an organization in GitHub, there is a ``Transfer ownership'' option at the bottom of the same ``Options'' tab of your repository settings page that allows you to do this.

[[r_transfer_project]]
.Transfer a project to anther GitHub user or Organization.
image::images/maint-11-transfer.png[Transfer]

This is helpful if you are abandoning a project and someone wants to take it over, or if your project is getting bigger and want to move it into an organization.

Not only does this move the repository along with all it's watchers and stars to another place, it also sets up a redirect from your URL to the new place. It will also redirect clones and fetches from Git, not just web requests.

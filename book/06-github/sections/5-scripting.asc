=== Написание скриптов для GitHub

К этому моменту вы уже рассмотрели особенности Github и узнали как устроен рабочий процесс. Однако для больших команд разработки и крупных проектов может быть необходима возможность настройки интеграции с внешними сервисами.

К счастью для нас Github достаточно гибкий и расширяемый инструмент. В этом разделе вы научитесь использовать веб хуки и API Github, чтобы вывести вашу работу с данным инструментом на новый уровень.

==== Сервисы и хуки

Самый простой способ управления сервисами и веб хуками - это перейти в панель администрирования вашего Git-репозитория и настроить взаимодействие с внешними сервисами.

===== Сервисы
Сначала разберемся с сервисами. Настроить сервисы и веб хуки можно в пункте "Settings" вашего репозитория, где ранее рассматривались участники проекта и изменение основной ветки по умолчанию. Нажмите на вкладку "Webhooks and Services" и вы увидите раздел как на рисунке <<r_services_hooks>>.

[[r_services_hooks]]
.Раздел конфигурации сервисов и хуков
image::images/scripting-01-services.png[Раздел конфигурации сервисов и хуков]

Здесь можно выбрать десятки разных сервисов, большинство из которых представляют собой интеграцию с другими коммерческими системами и системами с открытым исходным кодом.
Это преимущественно сервисы непрерывной интеграции, трекеры проблем и багов, чаты и сервисы для ведения документации. Мы рассмотрим самый простой - сервис электронной почты. Если вы выберете "email" в выпадающем списке всплывающего окна "Add Service", то получите страницу с настройками как на рисунке <<r_service_config>>.

[[r_service_config]]
.Настройка сервиса электронной почты
image::images/scripting-02-email-service.png[Сервис электронной почты]

Нажав на кнопку "Add Service", вы будете получать электронную почту, на указанный адрес, каждый раз когда кто-нибудь будет отправлять изменения в ваш репозиторий. Сервисы могут слушать большое количество разнообразных типов событий, но наиболее используемый тип, который вызывается при отправке изменений в репозиторий. Каждый тип событий представляет собой определенный набор данных, который впоследствии обрабатывается настраиваемыми сервисами.

Если вы используете какую-нибудь систему и хотели бы интегрировать ее с GitHub, то сначала вам необходимо убедиться, что для этого существует свой сервис. Например, если вы используете Jenkins для запуска тестов, вы можете использовать встроенный сервис Jenkins, чтобы запускать ваши тесты каждый раз когда кто-то будет отправлять свои изменения в ваш репозиторий.

===== Веб хуки

Чтобы более гибко настроить взаимодействие или если необходимый вам сервис не был найден в выпадающем списке, вы можете использовать универсальную систему веб хуков. Веб хуки GitHub репозитория очень просты. Вы указываете URL, выбираете событие и GitHub отправляет данные этого события посредством HTTP-запроса.

Как правило, это работает следующим образом. Вы настраиваете небольшой веб-сервис принимающий данные хука и затем производите с полученными данными какие-либо манипуляции.

Для того, чтобы добавить веб хук, нажмите на кнопку "Add webhook" в <<r_services_hooks>>. Перед вами откроется страница как на рисунке <<r_web_hook>>.

[[r_web_hook]]
.Настройка веб хука
image::images/scripting-03-webhook.png[Настройка веб хука]

Настройка не представляет из себя ничего сложного. В большинстве случаев вы просто вводите URL и секретный ключ, затем нажимаете "Add webhook". В качестве параметра указывается событие, по возникновению которого GitHub будет отправлять данные на ваш веб-сервис. По умолчанию это событие происходящее при отправке изменений в любую ветку вашего репозитория.

Рассмотрим небольшой пример веб-сервиса, настроенного на обработку хука. Мы будем использовать Ruby фреймворк называющийся Sinatra, который достаточно прост и позволяет с легкостью сделать то, что вам нужно.

Укажем, что вы хотите получать письмо на электронную почту если какой-то определенный участник проекта отправил изменения в определенную ветку нашего проекта, изменив
определенный файл. Сделать это можно, примерно так:

[source,ruby]
----
require 'sinatra'
require 'json'
require 'mail'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON

  # gather the data we're looking for
  pusher = push["pusher"]["name"]
  branch = push["ref"]

  # get a list of all the files touched
  files = push["commits"].map do |commit|
    commit['added'] + commit['modified'] + commit['removed']
  end
  files = files.flatten.uniq

  # check for our criteria
  if pusher == 'schacon' &&
     branch == 'ref/heads/special-branch' &&
     files.include?('special-file.txt')

    Mail.deliver do
      from     'tchacon@example.com'
      to       'tchacon@example.com'
      subject  'Scott Changed the File'
      body     "ALARM"
    end
  end
end
----

Вы получаете данные в формате JSON от GitHub, смотрите кто отправил их, в какую ветку отправлены эти изменения и какие файлы были изменены во всех этих коммитах, которые были вами получены. Затем вы проверяете их по заданным критериям и отправляете письмо на электронную почту, если всё совпадает.

В целях разработки и тестирования, вы можете воспользоваться консолью разработчика на той же самой странице, где вы настраивали ваш хук. Здесь можно посмотреть ранее отправленные данныe. Для выполненных хуков, представлена информация когда это было сделано, успешность выполнения, тело и заголовки как запроса, так и ответа обратно от вашего веб-сервиса. Это позволяет невероятно просто тестировать и отлаживать ваши веб хуки.

[[r_web_hook_debug]]
.Отладочная информация о веб хуках
image::images/scripting-04-webhook-debug.png[Отладка веб хуков]

Другая полезная возможность состоит в том, что вы можете переадресовать ранее отправленное событие на другой веб-сервис для отладки.

За дополнительной информацией как писать хуки и описания типов событий, которые вы можете прослушивать, перейдите в документацию GitHub-разработчика https://developer.github.com/webhooks/[^].

==== API GitHub

(((GitHub, API)))

Сервисы и хуки дают вам способ принятия уведомлений о событиях которые произошли с вашим репозиторием, но, что если вам нужно немного больше информации об этих событиях?
Что если вам нужно автоматизировать что-нибудь вроде добавления участников или названия проблемы?

Вот где GitHub API приходится кстати. GitHub имеет множество API-методов для большинства вещей, чтобы автоматизировать все, что вы можете сделать вручную на сайте. В этом разделе вы научитесь проходить аутентификацию и подключаться к API, комментировать проблемы и менять статус запроса на слияние.

==== Основы использования

Самая простая, базовая вещь, которую вы можете сделать - это простой GET-запрос к API, при котором не требуется аутентификация. То есть вы можете делать то, что может неавторизованный пользователь в общедоступном репозитории. Для примера, если вы хотите узнать больше о пользователе с именем "schacon", вы можете написать такой код:

[source,javascript]
----
$ curl https://api.github.com/users/schacon
{
  "login": "schacon",
  "id": 70,
  "avatar_url": "https://avatars.githubusercontent.com/u/70",
# …
  "name": "Scott Chacon",
  "company": "GitHub",
  "following": 19,
  "created_at": "2008-01-27T17:19:28Z",
  "updated_at": "2014-06-10T02:37:23Z"
}
----


Есть множество API-методов позволяющих получать информацию об организациях, проектах, проблемах, коммитах и абсолютно всего, что вы можете публично посмотреть на GitHub.
Вы можете даже использовать API, чтобы отобразить Markdown-разметку или найти шаблон .gitignore файла.

[source,javascript]
----
$ curl https://api.github.com/gitignore/templates/Java
{
  "name": "Java",
  "source": "*.class

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.ear

# virtual machine crash logs, see https://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
"
}
----


==== Написание комментариев в разделе проблем

Если вы хотите выполнить какое-либо действие на сайте, такое как комментирование проблемы или создание запроса на слияние, или если вы хотите просмотреть приватные данные, доступные для чтения вашему аккаунту, то вам необходимо пройти аутентификацию.

Есть несколько способов аутентификации.
Самый простой представляет собой ввод вашего логина и пароля, но обычно гораздо более разумной идеей является использование личного токена доступа.
Вы можете сгенерировать его во вкладке "Applications", настроек вашего аккаунта.

[[r_access_token]]
.Генерация вашего токена личного доступа во вкладке "Applications" из настроек страницы пользователя
image::images/scripting-05-access-token.png[Токен доступа]

Здесь будут запрошены какие права вы хотите предоставить вашему токену, а также описание к нему.
Не пренебрегайте оставлять содержательное описание к токену, потому что в будущем вы можете захотеть удалить неиспользуемый токен доступа и описание к нему может сильно помочь выбрать корректный из списка.

GitHub показывает токен доступа только один раз, поэтому сразу скопируйте его.
Теперь вы можете пройти аутентификацию используя токен доступа в ваших скриптах, вместо ввода логина и пароля. Создание личного токена доступа также позволяет выполнять запросы только в рамках установленных прав к этому токену, а также его в любой момент можно отозвать.

Используя аутентификацию вы увеличиваете свой лимит запросов.
Без аутентификации, вы можете делать только 60 запросов в час.
Но если вы прошли аутентификацию, этот лимит повышается до 5,000 запросов в час.

Теперь давайте оставим комментарий к одной из проблем.
Предположим вы хотите оставить комментарий к определенной проблеме, Issue #6.
Для того, чтобы сделать это вы отправляете HTTP Post-запрос к `repos/<user>/<repo>/issues/<num>/comments`, используя ранее сгенерированный токен в поле заголовка "Authorization" вашего запроса.

[source,javascript]
----
$ curl -H "Content-Type: application/json" \
       -H "Authorization: token TOKEN" \
       --data '{"body":"A new comment, :+1:"}' \
       https://api.github.com/repos/schacon/blink/issues/6/comments
{
  "id": 58322100,
  "html_url": "https://github.com/schacon/blink/issues/6#issuecomment-58322100",
  ...
  "user": {
    "login": "tonychacon",
    "id": 7874698,
    "avatar_url": "https://avatars.githubusercontent.com/u/7874698?v=2",
    "type": "User",
  },
  "created_at": "2014-10-08T07:48:19Z",
  "updated_at": "2014-10-08T07:48:19Z",
  "body": "A new comment, :+1:"
}
----

Теперь, если вы перейдете к разделу проблем, вы увидите, что появился комментарий, который вы только что успешно отправили в <<r_api_comment>>.

[[r_api_comment]]
.Комментарий отправленный через API GitHub
image::images/scripting-06-comment.png[Комментарий отправленный через API GitHub]

Вы можете использовать API для чего угодно, что можете выполнить на самом сайте:

* создавать и настраивать вехи
* присоединять участников к проблемам
* создавать запросы на слияние
* создавать и редактировать метки
* получать доступ к информации содержащейся в коммитах
* создавать новые коммиты и ветки
* открывать, закрывать и сливать запросы на слияние
* создавать и редактировать группы участников
* комментировать определенные строки кода к запросам на слияние
* искать другие проекты на сайте

Все это лишь неполный список того, что в можете делать.

==== Изменение статуса запроса на слияние

Рассмотрим еще один, самый полезный пример, который вам пригодится при работе с запросами на слияние.
Каждый коммит может иметь один или несколько статусов ассоциированных с ним. Существуют методы API, позволяющие добавлять или запрашивать этот статус.

Этими методами в основном пользуются системы непрерывной интеграции и сервисы тестирования, чтобы оперативно тестировать тот код, который только что был отправлен в репозиторий, а затем вернуть отчет прошел ли этот код все тесты или нет. Вы также можете проверять соответствует ли сообщение коммита надлежащему форматированию, соблюдает ли отправитель все ваши правила контрибуции и корректно ли подписан коммит -- все что угодно.

Предположим вы настраиваете хук для вашего репозитория, который получает ваш веб-сервис и проверяете есть ли строка `Signed-off-by` в сообщении к коммиту.

[source,ruby]
----
require 'httparty'
require 'sinatra'
require 'json'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON
  repo_name = push['repository']['full_name']

  # look through each commit message
  push["commits"].each do |commit|

    # look for a Signed-off-by string
    if /Signed-off-by/.match commit['message']
      state = 'success'
      description = 'Successfully signed off!'
    else
      state = 'failure'
      description = 'No signoff found.'
    end

    # post status to GitHub
    sha = commit["id"]
    status_url = "https://api.github.com/repos/#{repo_name}/statuses/#{sha}"

    status = {
      "state"       => state,
      "description" => description,
      "target_url"  => "http://example.com/how-to-signoff",
      "context"     => "validate/signoff"
    }
    HTTParty.post(status_url,
      :body => status.to_json,
      :headers => {
        'Content-Type'  => 'application/json',
        'User-Agent'    => 'tonychacon/signoff',
        'Authorization' => "token #{ENV['TOKEN']}" }
    )
  end
end
----

Надеюсь, для вас не составит труда разобраться, что здесь происходит.
Обработчик этого хука просматривает каждый коммит, который был отправлен в репозиторий и ищет строку 'Signed-off-by' в сообщении к коммиту, далее отправляет HTTP POST-запрос, содержащий статус выполнения, к `/repos/<user>/<repo>/statuses/<commit_sha>`.

В данном случае статус включает в себя:

* состояние ('success', 'failure', 'error')
* описание что произошло
* конечный URL, по которому пользователь может перейти за дополнительной информацией
* контекст, в случае если один коммит содержит несколько состояний одновременно

Для примера, сервис тестирования может передавать свой статус к коммиту, а сервис валидации добавляет к нему свой статус -- поле «context» как раз различает эти статусы.

Если кто-то открывает запрос на слияние, на GitHub и для этого настроен веб хук, то вы можете увидеть <<r_commit_status>>.

[[r_commit_status]]
.Статус коммита через API
image::images/scripting-07-status.png[Статус коммита через API]

Можно заметить маленькую зеленую галочку рядом с коммитом, которая указывает, что в тексте его сообщения содержится строка "Signed-off-by", а также красный крестик рядом с другим коммитом, который не был корректно подписан. Обратите внимание, что запрос на слияние принимает статус последнего коммита в ветке и предупреждает вас, если в нем содержатся ошибки. Использовать API GitHub для тестирования очень полезно, потому что это позволяет вам увидеть ошибки, которые вы скорее всего не хотели бы слить с вашей долгоживущей веткой.

==== Octokit

Хоть вы и можете делать практически все запросы к API используя обычный `curl`, посредством простых HTTP-запросов, как в рассмотренных нами выше примерах, все же существует библиотека с открытым исходным кодом, которая значительно облегчит использования API и сделает работу с ним более интуитивно-понятной.
На момент написания, эта библиотека поддерживается такими языками как Go, Objective-C, Ruby и .Net.
За получением более подробной информации переходите на https://github.com/octokit[^], чтобы дать возможность библиотеке составлять эти HTTP-запросы за вас.

Надеемся, что рассмотренные возможности помогут вам более гибко настроить GitHub под ваш рабочий процесс. Для получения более полной документации к API, а также описанию общих задач, переходите на https://developer.github.com[^].

[[r_advanced_merging]]
=== Продвинутое слияние

Обычно выполнять слияния в Git довольно легко.
Git упрощает повторные слияния с одной и той же веткой, таким образом, позволяя вам иметь очень долго живущую ветку, и вы можете сохранять ее всё это время в актуальном состоянии, часто разрешая маленькие конфликты, а не доводить дело до одного большого конфликта по завершению всех изменений.

Однако, иногда всё же будут возникать сложные конфликты.
В отличие от других систем управления версиями, Git не пытается быть слишком умным при разрешении конфликтов слияния.
Философия Git заключается в том, чтобы быть умным, когда слияние разрешается однозначно, но если возникает конфликт, он не пытается сумничать и разрешить его автоматически.
Поэтому, если вы слишком долго откладываете слияние двух быстрорастущих веток, вы можете столкнуться с некоторыми проблемами.

В этом разделе мы рассмотрим некоторые из возможных проблем и инструменты, которые предоставляет Git, чтобы помочь вам справиться с этими более сложными ситуациями.
Мы также рассмотрим некоторые другие нестандартные типы слияний, которые вы можете выполнять, и вы узнаете как можно откатить уже выполненные слияния.

==== Конфликты слияния

Мы рассказали некоторые основы разрешения конфликтов слияния в <<ch03-git-branching#r_basic_merge_conflicts>>, для работы с более сложными конфликтами Git предоставляет несколько инструментов, которые помогут вам понять, что произошло и как лучше обойтись с конфликтом.

Во-первых, если есть возможность, перед слиянием, в котором может возникнуть конфликт, позаботьтесь о том, чтобы ваша рабочая копия была без локальных изменений.
Если у вас есть несохранённые наработки, либо припрячьте их, либо сохраните их во временной ветке.
Таким образом, вы сможете легко отменить *любые* изменения, которые сделаете в рабочем каталоге.
Если при выполнении слияния вы не сохраните сделанные изменения, то некоторые из описанных ниже приёмов могут привести к утрате этих наработок.

Давайте рассмотрим очень простой пример.
Допустим, у нас есть файл с исходниками на Ruby, выводящими на экран  строку 'hello world'.

[source,ruby]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()
----

В нашем репозитории, мы создадим новую ветку по имени `whitespace` и выполним замену всех окончаний строк в стиле Unix на окончания строк в стиле DOS.
Фактически, изменения будут внесены в каждую строку, но изменятся только пробельные символы.
Затем мы заменим строку «hello world» на «hello mundo».

[source,console]
----
$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'Convert hello.rb to DOS'
[whitespace 3270f76] Convert hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -w
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'Use Spanish instead of English'
[whitespace 6d338d2] Use Spanish instead of English
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Теперь мы переключимся обратно на ветку `master` и добавим к функции некоторую документацию.

[source,console]
----
$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'Add comment documenting the function'
[master bec6336] Add comment documenting the function
 1 file changed, 1 insertion(+)
----

Теперь мы попытаемся слить в текущую ветку `whitespace` и в результате получим конфликты, так как изменились пробельные символы.

[source,console]
----
$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

[[r_abort_merge]]
===== Прерывание слияния

В данный момент у нас есть несколько вариантов дальнейших действий.
Во-первых, давайте рассмотрим как выйти из этой ситуации.
Если вы, возможно, не были готовы к конфликтам и на самом деле не хотите связываться с ними, вы можете просто отменить попытку слияния, используя команду `git merge --abort`.

[source,console]
----
$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master
----

Эта команда пытается откатить ваше состояние до того, что было до запуска слияния.
Завершиться неудачно она может только в случаях, если перед запуском слияния у вас были не припрятанные или не зафиксированные изменения в рабочем каталоге, во всех остальных случаях всё будет хорошо.

Если по каким-то причинам вы обнаружили себя в ужасном состоянии и хотите просто начать всё сначала, вы можете также выполнить `git reset --hard HEAD` (либо вместо `HEAD` указав то, куда вы хотите откатиться).
Но помните, что это откатит все изменения в рабочем каталоге, поэтому удостоверьтесь, что никакие из них вам не нужны.

===== Игнорирование пробельных символов

В данном конкретном случае конфликты связаны с пробельными символами.
Мы знаем это, так как это простой пример, но в реальных ситуациях это также легко определить при изучении конфликта, так как каждая строка в нем будет удалена и добавлена снова.
По умолчанию Git считает все эти строки изменёнными и поэтому не может слить файлы.

Стратегии слияния, используемой по умолчанию, можно передать аргументы, и некоторые из них предназначены для соответствующей настройки игнорирования изменений пробельных символов.
Если вы видите, что множество конфликтов слияния вызваны пробельными символами, то вы можете прервать слияние и запустить его снова, но на этот раз с опцией `-Xignore-all-space` или `-Xignore-space-change`.
Первая опция игнорирует изменения в любом **количестве** существующих пробельных символов, вторая игнорирует вообще все изменения пробельных символов.

[source,console]
----
$ git merge -Xignore-all-space whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Поскольку в этом примере реальные изменения файлов не конфликтуют, то при игнорировании изменений пробельных символов всё сольётся хорошо.

Это значительно облегчает жизнь, если кто-то в вашей команде любит временами заменять все пробелы на табуляции или наоборот.

[[r_manual_remerge]]
===== Ручное слияние файлов

Хотя Git довольно хорошо обрабатывает пробельные символы, с другими типами изменений он не может справиться автоматически, но существуют другие варианты исправления.
Например, представим, что Git не умеет обрабатывать изменения пробельных символов и нам нужно сделать это вручную.

То что нам действительно нужно -- это перед выполнением самого слияния прогнать сливаемый файл через программу `dos2unix`.
Как мы будем делать это?

Во-первых, мы перейдём в состояние конфликта слияния.
Затем нам необходимо получить копии _нашей_ версии файла, _их_ версии файла (из ветки, которую мы сливаем) и _общей_ версии (от которой ответвились первые две).
Затем мы исправим либо их версию, либо нашу и повторим слияние только для этого файла.

Получить эти три версии файла, на самом деле, довольно легко.
Git хранит все эти версии в индексе в разных «состояниях», каждое из которых имеет ассоциированный с ним номер.
Состояние 1 -- это общий предок, состояние 2 -- ваша версия и состояния 3 взято из `MERGE_HEAD` -- версия, которую вы сливаете («их» версия).

Вы можете извлечь копию каждой из этих версий конфликтующего файла с помощью команды `git show` и специального синтаксиса.

[source,console]
----
$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb
----

Если вы хотите что-то более суровое, то можете также воспользоваться служебной командой `ls-files -u` для получения SHA-1 хешей для каждого из этих файлов.

[source,console]
----
$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb
----

Выражение `:1:hello.rb` является просто сокращением для поиска такого SHA-1 хеша.

Теперь, когда в нашем рабочем каталоге присутствует содержимое всех трёх состояний, мы можем вручную исправить их, чтобы устранить проблемы с пробельными символами и повторно выполнить слияние с помощью малоизвестной команды `git merge-file`, которая делает именно это.

[source,console]
----
$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb

$ git diff -w
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()
----

Теперь у нас есть корректно слитый файл.
На самом деле, данный способ лучше, чем использование опции `ignore-all-space`, так как в его рамках вместо игнорирования изменений пробельных символов перед слиянием выполняется корректное исправление таких изменений.
При слиянии с `ignore-all-space` мы в результате получим несколько строк с окончаниями в стиле DOS, то есть в одном файле смешаются разные стили окончания строк.

Если перед коммитом изменений вы хотите посмотреть какие в действительности были различия между состояниями, то можете воспользоваться командой `git diff`, сравнивающей содержимое вашего рабочего каталога, которое будет зафиксировано как результат слияния, с любым из трёх состояний.
Давайте посмотрим на все эти сравнения.

Чтобы сравнить результат слияния с тем, что было в вашей ветке до слияния, или другими словами увидеть, что привнесло данное слияние, вы можете выполнить `git diff --ours`

[source,console]
----
$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

Итак, здесь мы можем легко увидеть что же произошло с нашей веткой, какие изменения в действительности внесло слияние в данный файл -- изменение только одной строки.

Если вы хотите узнать чем результат слияния отличается от сливаемой ветки, то можете выполнить команду `git diff --theirs`.
В этом и следующем примере мы используем опцию `-w` для того, чтобы не учитывать изменения в пробельных символах, так как мы сравниваем результат с тем, что есть в Git, а не с нашим исправленным файлом `hello.theirs.rb`.

[source,console]
----
$ git diff --theirs -w
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end
----

И, наконец, вы можете узнать как изменился файл по сравнению сразу с обеими ветками с помощью команды `git diff --base`.

[source,console]
----
$ git diff --base -w
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

В данный момент мы можем использовать команду `git clean` для того, чтобы удалить не нужные более дополнительные файлы, созданные нами для выполнения слияния.

[source,console]
----
$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb
----

[[r_checking_out_conflicts]]
===== Использование `checkout` в конфликтах

Возможно, нас по каким-то причинам не устраивает необходимость выполнения слияния в текущий момент, или мы не можем хорошо исправить конфликт и нам необходимо больше информации.

Давайте немного изменим пример.
Предположим, что у нас есть две долгоживущих ветки, каждая из которых имеет несколько коммитов, что при слиянии приводит к справедливому конфликту.

[source,console]
----
$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) Update README
* 9af9d3b Create README
* 694971d Update phrase to 'hola world'
| * e3eb223 (mundo) Add more tests
| * 7cff591 Create initial testing script
| * c3ffff1 Change text to 'hello mundo'
|/
* b7dcc89 Initial hello world code
----

У нас есть три уникальных коммита, которые присутствуют только в ветке `master` и три других, которые присутствуют в ветке `mundo`.
Если мы попытаемся слить ветку `mundo`, то получим конфликт.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

Мы хотели бы увидеть в чем состоит данный конфликт.
Если мы откроем конфликтующий файл, то увидим нечто подобное:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> mundo
end

hello()
----

В обеих сливаемых ветках в этот файл было добавлено содержимое, но в некоторых коммитах изменялись одни и те же строки, что и привело к конфликту.

Давайте рассмотрим несколько находящихся в вашем распоряжении инструментов, которые позволяют определить как возник этот конфликт.
Возможно, не понятно как именно вы должны исправить конфликт и вам требуется больше информации.

Полезным в данном случае инструментом является команда `git checkout` с опцией `--conflict'.
Она заново выкачает файл и заменит маркеры конфликта.
Это может быть полезно, если вы хотите восстановить маркеры конфликта и попробовать разрешить его снова.

В качестве значения опции `--conflict` вы можете указывать `diff3` или `merge` (последнее значение используется по умолчанию).
Если вы укажете `diff3`, Git будет использовать немного другую версию маркеров конфликта -- помимо «нашей» и «их» версий файлов будет также отображена «базовая» версия, и таким образом вы получите больше информации.

[source,console]
----
$ git checkout --conflict=diff3 hello.rb
----

После того, как вы выполните эту команду, файл будет выглядеть так:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end

hello()
----

Если вам нравится такой формат вывода, то вы можете использовать его по умолчанию для будущих конфликтов слияния, установив параметру `merge.conflictstyle` значение `diff3`.

[source,console]
----
$ git config --global merge.conflictstyle diff3
----

Команде `git checkout` также можно передать опции `--ours` и `--theirs`, которые позволяют действительно быстро выбрать одну из версий файлов, не выполняя слияния совсем.

Это может быть действительно полезным при возникновении конфликтов в бинарных файлах (в этом случае вы можете просто выбрать одну из версий), или при необходимости слить из другой ветки только некоторые файлы (в этом случае вы можете выполнить слияние, а затем перед коммитом переключить нужные файлы на требуемые версии).

[[r_merge_log]]
===== История при слиянии

Другой полезный инструмент при разрешении конфликтов слияния -- это команда `git log`.
Она поможет вам получить информацию о том, что могло привести к возникновению конфликтов.
Временами может быть очень полезным просмотреть историю, чтобы понять почему в двух ветках разработки изменялась одна и та же область кода.

Для получения полного списка всех уникальных коммитов, которые были сделаны в любой из сливаемых веток, мы можем использовать синтаксис «трёх точек», который мы изучили в <<r_triple_dot>>.

[source,console]
----
$ git log --oneline --left-right HEAD...MERGE_HEAD
< f1270f7 Update README
< 9af9d3b Create README
< 694971d Update phrase to 'hola world'
> e3eb223 Add more tests
> 7cff591 Create initial testing script
> c3ffff1 Change text to 'hello mundo'
----

Это список всех шести коммитов, включённых в слияние, с указанием также ветки разработки, в которой находится каждый из коммитов.

Мы также можем сократить его, попросив предоставить нам более специализированную информацию.
Если мы добавим опцию `--merge` к команде `git log`, то она покажет нам только те коммиты, в которых изменялся конфликтующий в данный момент файл.

[source,console]
----
$ git log --oneline --left-right --merge
< 694971d Update phrase to 'hola world'
> c3ffff1 Change text to 'hello mundo'
----

Если вы выполните эту команду с опцией `-p`, то получите только список изменений файла, на котором возник конфликт.
Это может быть **действительно** полезным для быстрого получения информации, которая необходима, чтобы понять почему что-либо конфликтует и как наиболее правильно это разрешить.

===== Комбинированный формат изменений

Так как Git добавляет в индекс все успешные результаты слияния, то при вызове `git diff` в состоянии конфликта слияния будет отображено только то, что сейчас конфликтует.
Это может быть полезно, так как вы сможете увидеть какие ещё конфликты нужно разрешить.

Если вы выполните `git diff` сразу после конфликта слияния, то получите информацию в довольно своеобразном формате.

[source,console]
----
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++<<<<<<< HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++>>>>>>> mundo
  end

  hello()
----

Такой формат называется «комбинированным» («Combined Diff»), для каждого различия в нем содержится два раздела с информацией.
В первом разделе отображены различия строки (добавлена она или удалена) между «вашей» веткой и содержимым вашего рабочего каталога, а во втором разделе содержится тоже самое, но между «их» веткой и рабочим каталогом.

Таким образом, в данном примере вы можете увидеть строки `<<<<<<<` и `>>>>>>>` в файле в вашем рабочем каталоге, хотя они отсутствовали в сливаемых ветках.
Это вполне оправдано, потому что, добавляя их, инструмент слияния предоставляет вам дополнительную информацию, но предполагается, что мы удалим их.

Если мы разрешим конфликт и снова выполним команду `git diff`, то получим ту же информацию, но в немного более полезном представлении.

[source,console]
----
$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

В этом выводе указано, что строка «hola world» при слиянии присутствовала в «нашей» ветке, но отсутствовала в рабочей копии, строка «hello mundo» была в «их» ветке, но не в рабочей копии, и, наконец, «hola mundo» не была ни в одной из сливаемых веток, но сейчас присутствует в рабочей копии.
Это бывает полезно просмотреть перед коммитом разрешения конфликта.

Такую же информацию вы можете получить и после выполнения слияния с помощью команды `git log`, узнав таким образом как был разрешён конфликт.
Git выводит информацию в таком формате, если вы выполните `git show` для коммита слияния или вызовете команду `git log -p` с опцией `--cc' (без неё данная команда не показывает изменения для коммитов слияния).

[source,console]
----
$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

[[r_undoing_merges]]
==== Отмена слияний

Теперь когда вы знаете как создать коммит слияния, вы можете сделать его по ошибке.
Одна из замечательных вещей в работе с Git -- это то, что ошибки совершать не страшно, так как есть возможность исправить их (и в большинстве случаев сделать это просто).

Коммит слияния не исключение.
Допустим, вы начали работать в тематической ветке, случайно слили ее в `master`, и теперь ваша история коммитов выглядит следующим образом:

.Случайный коммит слияния
image::images/undomerge-start.png["Случайный коммит слияния"]

Есть два подхода к решению этой проблемы, в зависимости от того, какой результат вы хотите получить.

===== Исправление ссылок

Если нежелаемый коммит слияния существует только в вашем локальном репозитории, то простейшее и лучшее решение состоит в перемещении веток так, чтобы они указывали туда куда вам нужно.
В большинстве случаев, если вы после случайного `git merge` выполните команду `git reset --hard HEAD~`, то указатели веток восстановятся так, что будут выглядеть следующим образом:

.История после `git reset --hard HEAD~`
image::images/undomerge-reset.png["История после `git reset --hard HEAD~`"]

Мы рассматривали команду `reset` ранее в <<r_git_reset>>, поэтому вам должно быть не сложно разобраться с тем, что здесь происходит.
Здесь небольшое напоминание: `reset --hard` обычно выполняет три шага:

. Перемещает ветку, на которую указывает HEAD.
  В данном случае мы хотим переместить `master` туда, где она была до коммита слияния (`C6`).
. Приводит индекс к такому же виду что и HEAD.
. Приводит рабочий каталог к такому же виду, что и индекс.

Недостаток этого подхода состоит в изменении истории, что может привести к проблемам в случае совместно используемого репозитория.
Загляните в <<ch03-git-branching#r_rebase_peril>>, чтобы узнать что именно может произойти; кратко говоря, если у других людей уже есть какие-то из изменяемых вами коммитов, вы должны отказаться от использования `reset`.
Этот подход также не будет работать, если после слияния уже был сделан хотя бы один коммит; перемещение ссылки фактически приведёт к потере этих изменений.

[[r_reverse_commit]]
===== Отмена коммита

Если перемещение указателей ветки вам не подходит, Git предоставляет возможность сделать новый коммит, который откатывает все изменения, сделанные в другом.
Git называет эту операцию «восстановлением» («revert»), в данном примере вы можете вызвать её следующим образом:

[source,console]
----
$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"
----

Опция `-m 1` указывает какой родитель является «основной веткой» и должен быть сохранен.
Когда вы выполняете слияние в `HEAD` (`git merge topic`), новый коммит будет иметь двух родителей: первый из них `HEAD` (`C6`), а второй -- вершина ветки, которую сливают с текущей (`C4`).
В данном случае, мы хотим отменить все изменения, внесённые слиянием родителя #2 (`C4`), и сохранить при этом всё содержимое из родителя #1 (`C6`).

История с коммитом восстановления (отменой коммита слияния) выглядит следующим образом:

.История после `git revert -m 1`
image::images/undomerge-revert.png["История после `git revert -m 1`"]

Новый коммит `^M` имеет точно такое же содержимое как `C6`, таким образом, начиная с нее всё выглядит так, как будто слияние никогда не выполнялось, за тем лишь исключением, что «теперь уже не слитые» коммиты всё также присутствуют в истории `HEAD`.
Git придет в замешательство, если вы вновь попытаетесь слить `topic` в ветку `master`:

[source,console]
----
$ git merge topic
Already up-to-date.
----

В ветке `topic` нет ничего, что ещё недоступно из ветки `master`.
Плохо, что в случае добавления новых наработок в `topic`, при повторении слияния Git добавит _только_ те изменения, которые были сделаны после отмены слияния:

.История с плохим слиянием
image::images/undomerge-revert2.png["История с плохим слиянием"]

Лучшим решением данной проблемы является откат коммита отмены слияния, так как теперь вы хотите внести изменения, которые были отменены, а *затем* создание нового коммита слияния:

[source,console]
----
$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic
----

.История после повторения отменённого слияния
image::images/undomerge-revert3.png["История после повторения отменённого слияния"]

В этом примере, `M` и `^M` отменены.
В коммите `^^M`, фактически, сливаются изменения из `C3` и `C4`, а в `C8` -- изменения из  `C7`, таким образом, ветка `topic` полностью слита.

==== Другие типы слияний

До этого момента мы рассматривали типичные слияния двух веток, которые обычно выполняются с использованием стратегии слияния, называемой «рекурсивной».
Но существуют и другие типы слияния веток.
Давайте кратко рассмотрим некоторые из них.

===== Выбор «нашей» или «их» версий

Во-первых, существует ещё один полезный приём, который мы можем использовать в обычном «рекурсивном» режиме слияния.
Мы уже видели опции `ignore-all-space` и `ignore-space-change`, которые передаются с префиксом `-X`, но мы можем также попросить Git при возникновении конфликта использовать ту или иную версию файлов.

По умолчанию, когда Git при слиянии веток замечает конфликт, он добавляет в код маркеры конфликта, отмечает файл как конфликтующий и позволяет вам разрешить его.
Если же вместо ручного разрешения конфликта вы хотите, чтобы Git просто использовал какую-то определённую версию файла, а другую игнорировал, то вы можете передать команде `merge` одну из двух опций `-Xours` или `-Xtheirs`.

В этом случае Git не будет добавлять маркеры конфликта.
Все неконфликтующие изменения он сольёт, а для конфликтующих он целиком возьмёт ту версию, которую вы указали (это относится и к бинарным файлам).

Если мы вернёмся к примеру «hello world», который использовали раньше, то увидим, что попытка слияния в нашу ветку приведёт к конфликту.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.
----

Однако, если мы выполним слияние с опцией `-Xours` или `-Xtheirs`, конфликта не будет.

[source,console]
----
$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh
----

В этом случае, вместо добавления в файл маркеров конфликта с «hello mundo» в качестве одной версии и с «hola world» в качестве другой, Git просто выберет «hola world».
Однако, все другие неконфликтующие изменения будут слиты успешно.

Такая же опция может быть передана команде `git merge-file`, которую мы обсуждали ранее, то есть для слияния отдельных файлов можно использовать команду `git merge-file --ours`.

На случай если вам нужно нечто подобное, но вы хотите, чтобы Git даже не пытался сливать изменения из другой версии, существует более суровый вариант -- _стратегия_ слияния «ours».
Важно отметить, что это не тоже самое что _опция_ «ours» рекурсивной стратегии слияния.

Фактически, эта стратегия выполнит ненастоящее слияние.
Она создаст новый коммит слияния, у которой родителями будут обе ветки, но при этом данная стратегия даже не взглянет на ветку, которую вы сливаете.
В качестве результата слияния она просто оставляет тот код, который находится в вашей текущей ветке.

[source,console]
----
$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$
----

Вы можете видеть, что между веткой, в которой мы были, и результатом слияния нет никаких отличий.

Это часто бывает полезно, когда нужно заставить Git считать, что ветка уже слита, а реальное слияние отложить на потом.
Для примера предположим, что вы создали ветку `release` и проделали в ней некоторую работу, которую когда-то впоследствии захотите слить обратно в `master`.
Тем временем в `master` были сделаны некоторые исправления, которые необходимо перенести также в вашу ветку `release`.
Вы можете слить ветку с исправлениями в `release`, а затем выполнить `merge -s ours` этой ветки в `master` (хотя исправления в ней уже присутствуют), так что позже, когда вы будете снова сливать ветку `release`, не возникнет конфликтов, связанных с этими исправлениями.

include::subtree-merges.asc[]

[[r_git_reset]]
=== Раскрытие тайн reset

Перед тем, как перейти к более специализированными утилитам, давайте поговорим о `reset` и `checkout`.
Эти команды кажутся самыми непонятными из всех, которые есть в Git, когда вы в первый раз сталкиваетесь с ними.
Они делают так много, что попытки по-настоящему их понять и правильно использовать кажутся безнадёжными.
Для того, чтобы всё же достичь этого, мы советуем воспользоваться простой аналогией.

==== Три дерева

Разобраться с командами `reset` и `checkout` будет проще, если считать, что Git управляет содержимым трёх различных деревьев.
Здесь под «деревом» мы понимаем «набор файлов», а не специальную структуру данных.
(В некоторых случаях индекс ведет себя не совсем так, как дерево, но для наших текущих целей его проще представлять именно таким.)

В своих обычных операциях Git управляет тремя деревьями:

[cols="1,2",options="header"]
|================================
| Дерево            | Назначение
| HEAD              | Снимок последнего коммита, родитель следующего
| Индекс            | Снимок следующего намеченного коммита
| Рабочий Каталог   | Песочница
|================================

===== HEAD

HEAD -- это указатель на текущую ветку, которая, в свою очередь, является указателем на последний коммит, сделанный в этой ветке.
Это значит, что HEAD будет родителем следующего созданного коммита.
Как правило, самое простое считать HEAD снимком *вашего последнего коммита*.

На самом деле, довольно легко увидеть, что представляет из себя этот снимок.
Ниже приведён пример получения содержимого каталога и контрольных сумм для каждого файла в HEAD:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

Команды `cat-file` и `ls-tree` являются «служебными» (_plumbing_) командами, которые используются внутри системы и не требуются при ежедневной работе, но они помогают нам разобраться, что же происходит на самом деле.

[[r_the_index]]
===== Индекс

Индекс -- это ваш *следующий намеченный коммит*.
Мы также упоминали это понятие как «область подготовленных изменений» Git -- то, что Git просматривает, когда вы выполняете `git commit`.

Git заполняет индекс списком изначального содержимого всех файлов, выгруженных в последний раз в ваш рабочий каталог.
Затем вы заменяете некоторые из таких файлов их новыми версиями и команда `git commit' преобразует изменения в дерево для нового коммита.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

Повторим, здесь мы используем служебную команду `ls-files`, которая показывает вам, как выглядит сейчас ваш индекс.

Технически, индекс не является древовидной структурой, на самом деле, он реализован как сжатый список (_flattened manifest_) -- но для наших целей такого представления будет достаточно.

===== Рабочий Каталог

Наконец, у вас есть рабочий каталог.
Два других дерева сохраняют свое содержимое эффективным, но неудобным способом внутри каталога `.git`.
Рабочий Каталог распаковывает их в настоящие файлы, что упрощает для вас их редактирование.
Считайте Рабочий Каталог *песочницей*, где вы можете опробовать изменения перед их коммитом в индекс (область подготовленных изменений) и затем в историю.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== Технологический процесс

Основное предназначение Git -- это сохранение снимков последовательно улучшающихся состояний вашего проекта, путём управления этими тремя деревьями.

image::images/reset-workflow.png[]

Давайте рассмотрим этот процесс: пусть вы перешли в новый каталог, содержащий один файл.
Данную версию этого файла будем называть *v1* и изображать голубым цветом.
Выполним команду `git init`, которая создаст Git-репозиторий, у которого ссылка HEAD будет указывать на ещё несуществующую ветку (`master` пока не существует).

image::images/reset-ex1.png[]

На данном этапе только дерево Рабочего Каталога содержит данные.

Теперь мы хотим закоммитить этот файл, поэтому мы используем `git add` для копирования содержимого Рабочего Каталога в Индекс.

image::images/reset-ex2.png[]

Затем, мы выполняем команду `git commit`, которая сохраняет содержимое Индекса как неизменяемый снимок, создает объект коммита, который указывает на этот снимок, и обновляет `master` так, чтобы он тоже указывал на этот коммит.

image::images/reset-ex3.png[]

Если сейчас выполнить `git status`, то мы не увидим никаких изменений, так как все три дерева одинаковые.

Теперь мы хотим внести изменения в файл и закоммитить его.
Мы пройдём через всё ту же процедуру; сначала мы отредактируем файл в нашем рабочем каталоге.
Давайте называть эту версию файла *v2* и обозначать красным цветом.

image::images/reset-ex4.png[]

Если сейчас мы выполним `git status`, то увидим, что файл выделен красным в разделе «Изменения, не подготовленные к коммиту», так как его представления в Индексе и Рабочем Каталоге различны.
Затем мы выполним `git add` для этого файла, чтобы поместить его в Индекс.

image::images/reset-ex5.png[]

Если сейчас мы выполним `git status`, то увидим, что этот файл выделен зелёным цветом в разделе «Изменения, которые будут закоммичены», так как Индекс и HEAD различны -- то есть, наш следующий намеченный коммит сейчас отличается от нашего последнего коммита.
Наконец, мы выполним `git commit`, чтобы окончательно совершить коммит.

image::images/reset-ex6.png[]

Сейчас команда `git status` не показывает ничего, так как снова все три дерева одинаковые.

Переключение веток и клонирование проходят через похожий процесс.
Когда вы переключаетесь (checkout) на ветку, *HEAD* начинает также указывать на новую ветку, ваш *Индекс* замещается снимком коммита этой ветки, и затем содержимое *Индекса* копируется в ваш *Рабочий Каталог*.

==== Назначение reset

Команда `reset` становится более понятной, если рассмотреть её с учётом вышеизложенного.

В следующих примерах предположим, что мы снова изменили файл `file.txt` и закоммитили его в третий раз.
Так что наша история теперь выглядит так:

image::images/reset-start.png[]

Давайте теперь внимательно проследим, что именно происходит при вызове `reset`.
Эта команда простым и предсказуемым способом управляет тремя деревьями, существующими в Git.
Она выполняет три основных операции.

===== Шаг 1: Перемещение HEAD

Первое, что сделает `reset` -- переместит то, на что указывает HEAD.
Обратите внимание, изменяется не сам HEAD (что происходит при выполнении команды `checkout`); `reset` перемещает ветку, на которую указывает HEAD.
Таким образом, если HEAD указывает на ветку `master` (то есть вы сейчас работаете с веткой `master`), выполнение команды `git reset 9e5e6a4` сделает так, что `master` будет указывать на `9e5e6a4`.

image::images/reset-soft.png[]

Не важно с какими опциями вы вызвали команду `reset` _с указанием коммита_ (`reset` также можно вызывать с указанием пути), она всегда будет пытаться сперва сделать данный шаг.
При вызове `reset --soft` на этом выполнение команды и остановится.

Теперь взгляните на диаграмму и постарайтесь разобраться, что случилось: фактически была отменена последняя команда `git commit`.
Когда вы выполняете `git commit`, Git создает новый коммит и перемещает на него ветку, на которую указывает HEAD.
Если вы выполняете `reset` на `HEAD~` (родителя HEAD), то вы перемещаете ветку туда, где она была раньше, не изменяя при этом ни Индекс, ни Рабочий Каталог.
Вы можете обновить Индекс и снова выполнить `git commit`, таким образом добиваясь того же, что делает команда `git commit --amend` (смотрите <<r_git_amend>>).

===== Шаг 2: Обновление Индекса (--mixed)

Заметьте, если сейчас вы выполните `git status`, то увидите отмеченные зелёным цветом изменения между Индексом и новым HEAD.

Следующим, что сделает `reset`, будет обновление Индекса содержимым того снимка, на который указывает HEAD.

image::images/reset-mixed.png[]

Если вы указали опцию `--mixed`, выполнение `reset` остановится на этом шаге.
Такое поведение также используется по умолчанию, поэтому если вы не указали совсем никаких опций (в нашем случае `git reset HEAD~`), выполнение команды также остановится на этом шаге.

Снова взгляните на диаграмму и постарайтесь разобраться, что произошло: отменен не только ваш последний `commit`, но также и _добавление в индекс_ всех файлов.
Вы откатились назад до момента выполнения команд `git add` и `git commit`.

===== Шаг 3: Обновление Рабочего Каталога (--hard)

Третье, что сделает `reset` -- это приведение вашего Рабочего Каталога к тому же виду, что и Индекс.
Если вы используете опцию `--hard`, то выполнение команды будет продолжено до этого шага.

image::images/reset-hard.png[]

Давайте разберемся, что сейчас случилось.
Вы отменили ваш последний коммит, результаты выполнения команд `git add` и `git commit`, а также **все** изменения, которые вы сделали в рабочем каталоге.

Важно отметить, что только указание этого флага (`--hard`) делает команду `reset` опасной, это один из немногих случаев, когда Git действительно удаляет данные.
Все остальные вызовы `reset` легко отменить, но при указании опции `--hard` команда принудительно перезаписывает файлы в Рабочем Каталоге.
В данном конкретном случае, версия *v3* нашего файла всё ещё остаётся в коммите внутри базы данных Git и мы можем вернуть её, просматривая наш `reflog`, но если вы не коммитили эту версию, Git перезапишет файл и её уже нельзя будет восстановить.

===== Резюме

Команда `reset` в заранее определённом порядке перезаписывает три дерева Git, останавливаясь тогда, когда вы ей скажете:

1. Перемещает ветку, на которую указывает HEAD _(останавливается на этом, если указана опция `--soft`)_
2. Делает Индекс таким же как и HEAD _(останавливается на этом, если не указана опция `--hard`)_
3. Делает Рабочий Каталог таким же как и Индекс.

==== Reset с указанием пути

Основной форме команды `reset` (без опций `--soft` и `--hard`) вы также можете передавать путь, с которым она будет оперировать.
В этом случае, `reset` пропустит первый шаг, а на остальных будет работать только с указанным файлом или набором файлов.
Первый шаг пропускается, так как HEAD является указателем и не может ссылаться частично на один коммит, а частично на другой.
Но Индекс и Рабочий Каталог _могут_ быть изменены частично, поэтому `reset` выполняет шаги 2 и 3.

Итак, предположим вы выполнили команду `git reset file.txt`.
Эта форма записи (так как вы не указали ни SHA-1 коммита, ни ветку, ни опций `--soft` или `--hard`) является сокращением для `git reset --mixed HEAD file.txt`, которая:

1. Перемещает ветку, на которую указывает HEAD _(будет пропущено)_
2. Делает Индекс таким же как и HEAD _(остановится здесь)_

То есть, фактически, она копирует файл `file.txt` из HEAD в Индекс.

image::images/reset-path1.png[]

Это создает эффект _отмены индексации_ файла.
Если вы посмотрите на диаграммы этой команды и команды `git add`, то увидите, что их действия прямо противоположные.

image::images/reset-path2.png[]

Именно поэтому в выводе `git status` предлагается использовать такую команду для отмены индексации файла.
(Смотрите подробности в <<ch02-git-basics#r_unstaging>>.)

Мы легко можем заставить Git «брать данные не из HEAD», указав коммит, из которого нужно взять версию этого файла.
Для этого мы должны выполнить следующее `git reset eb43bf file.txt`.

image::images/reset-path3.png[]

Можно считать, что, фактически, мы в Рабочем Каталоге вернули содержимое файла к версии *v1*, выполнили для него `git add`, а затем вернули содержимое обратно к версии *v3* (в действительности все эти шаги не выполняются).
Если сейчас мы выполним `git commit`, то будут сохранены изменения, которые возвращают файл к версии *v1*, но при этом файл в Рабочем Каталоге никогда не возвращался к такой версии.

Заметим, что как и команде `git add`, `reset` можно указывать опцию `--patch` для отмены индексации части содержимого.
Таким способом вы можете избирательно отменять индексацию или откатывать изменения.

==== Слияние коммитов

Давайте посмотрим, как, используя вышеизложенное, сделать кое-что интересное -- слияние коммитов.

Допустим, у вас есть последовательность коммитов с сообщениями вида «упс.», «В работе» и «позабыл этот файл».
Вы можете использовать `reset` для того, чтобы просто и быстро слить их в один.
(В <<r_squashing>> представлен другой способ сделать то же самое, но в данном примере проще воспользоваться `reset`.)

Предположим, у вас есть проект, в котором первый коммит содержит один файл, второй коммит добавляет новый файл и изменяет первый, а третий коммит снова изменяет первый файл.
Второй коммит был сделан в процессе работы и вы хотите слить его со следующим.

image::images/reset-squash-r1.png[]

Вы можете выполнить `git reset --soft HEAD~2`, чтобы вернуть ветку HEAD на какой-то из предыдущих коммитов (на первый коммит, который вы хотите оставить):

image::images/reset-squash-r2.png[]

Затем просто снова выполните `git commit`:

image::images/reset-squash-r3.png[]

Теперь вы можете видеть, что ваша «достижимая» история (история, которую вы впоследствии отправите на сервер), сейчас выглядит так -- у вас есть первый коммит с файлом `file-a.txt` версии *v1*, и второй, который изменяет файл `file-a.txt` до версии *v3* и добавляет `file-b.txt`.
Коммита, который содержал файл версии *v2* не осталось в истории.


==== Сравнение с `checkout`

Наконец, вы можете задаться вопросом, в чем же состоит отличие между `checkout` и `reset`.
Как и `reset`, команда `checkout` управляет тремя деревьями Git, и также её поведение зависит от того указали ли вы путь до файла или нет.

===== Без указания пути

Команда `git checkout [branch]` очень похожа на `git reset --hard [branch]`, в процессе их выполнения все три дерева изменяются так, чтобы выглядеть как `[branch]`.
Но между этими командами есть два важных отличия.

Во-первых, в отличие от `reset --hard`, команда `checkout` бережно относится к рабочему каталогу, и проверяет, что она не трогает файлы, в которых есть изменения.
В действительности, эта команда поступает немного умнее -- она пытается выполнить в Рабочем Каталоге простые слияния так, чтобы все файлы, которые вы _не_ изменяли, были обновлены.
С другой стороны, команда `reset --hard` просто заменяет всё целиком, не выполняя проверок.

Второе важное отличие заключается в том, как эти команды обновляют HEAD.
В то время как `reset` перемещает ветку, на которую указывает HEAD, команда `checkout` перемещает сам HEAD так, чтобы он указывал на другую ветку.

Например, пусть у нас есть ветки `master` и `develop`, которые указывают на разные коммиты и мы сейчас находимся на ветке `develop` (то есть HEAD указывает на неё).
Если мы выполним `git reset master`, сама ветка `develop` станет ссылаться на тот же коммит, что и `master`.
Если мы выполним `git checkout master`, то `develop` не изменится, но изменится HEAD.
Он станет указывать на `master`.

Итак, в обоих случаях мы перемещаем HEAD на коммит A, но важное отличие состоит в том, _как_ мы это делаем.
Команда `reset` переместит также и ветку, на которую указывает HEAD, а `checkout` перемещает только сам HEAD.

image::images/reset-checkout.png[]

===== С указанием пути

Другой способ выполнить `checkout` состоит в том, чтобы указать путь до файла.
В этом случае, как и для команды `reset`, HEAD не перемещается.
Эта команда как и `git reset [branch] file` обновляет файл в индексе версией из коммита, но дополнительно она обновляет и файл в рабочем каталоге.
То же самое сделала бы команда `git reset --hard [branch] file` (если бы `reset` можно было бы так запускать) -- это небезопасно для рабочего каталога и не перемещает HEAD.

Также как `git reset` и `git add`, команда `checkout` принимает опцию `--patch` для того, чтобы позволить вам избирательно откатить изменения содержимого файла по частям.

==== Заключение

Надеюсь, вы разобрались с командой `reset` и можете её спокойно использовать.
Но, возможно, вы всё ещё немного путаетесь, чем именно она отличается от `checkout`, и не запомнили всех правил, используемых в различных вариантах вызова.

Ниже приведена памятка того, как эти команды воздействуют на каждое из деревьев.
В столбце «HEAD» указывается «REF» если эта команда перемещает ссылку (ветку), на которую HEAD указывает, и «HEAD» если перемещается только сам HEAD.
Обратите особое внимание на столбец «Сохранность РК?» -- если в нем указано *NO*, то хорошенько подумайте прежде чем выполнить эту команду.

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Индекс | Рабочий Каталог | Сохранность РК?
| *На уровне коммитов (без указания путей)* | | | |
| `reset --soft [commit]` | REF | NO | NO | YES
| `reset [commit]` | REF | YES | NO | YES
| `reset --hard [commit]` | REF | YES | YES | *NO*
| `checkout [commit]` | HEAD | YES | YES | YES
| *На уровне файлов (с указанием путей)* | | | |
| `reset (commit) [file]` | NO | YES | NO | YES
| `checkout (commit) [file]` | NO | YES | YES | *NO*
|================================

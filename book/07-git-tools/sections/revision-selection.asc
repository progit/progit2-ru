[[r_revision_selection]]
=== Выбор ревизии

Git позволяет различными способами указать коммиты или их диапазоны.
Эти способы не всегда очевидны, но их полезно знать.

==== Одиночные ревизии

Конечно, вы можете ссылаться на коммит по его SHA-1 хешу, но существуют более удобные для человека способы.
В данном разделе описываются различные способы обращения к одному коммиту.

==== Сокращённый SHA-1

Git достаточно умен, чтобы понять какой коммит имеется ввиду по нескольким первым символам его хеша, если указанная часть SHA-1 имеет в длину по крайней мере четыре символа и однозначна -- то есть в текущем репозитории существует только один объект с таким частичным SHA-1.

Например, предположим, чтобы найти некоторый коммит, вы выполнили команду `git log` и нашли коммит, в которой добавили определённую функциональность:

[source,console]
----
$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff
----

Предположим, что в нашем примере это коммит `1c002dd....`.
Если вы хотите выполнить для него `git show`, то следующие команды эквиваленты (предполагается, что сокращения однозначны):

[source,console]
----
$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d
----

Git может вычислить уникальные сокращения для ваших значений SHA-1.
Если вы передадите опцию `--abbrev-commit` команде `git log`, в выводе будут использоваться сокращённые значения, сохраняющие уникальность; по умолчанию используется семь символов, но для сохранения уникальности SHA-1 могут использоваться более длинные значения.

[source,console]
----
$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit
----

Обычно от восьми до десяти символов более чем достаточно для сохранения уникальности значений в проекте.

Например, в ядре Linux, который является довольно большим проектом с более чем 450 тыс. коммитов и 3.6 млн. объектов, отсутствуют объекты, чьи SHA-1 совпадают более чем в 11 первых символах.

[NOTE]
.Небольшое замечание о SHA-1
====

Большинство людей в этом месте начинают беспокоиться о том, что будет, если у них в репозитории случайно появятся два объекта с одинаковыми значениями SHA-1.
Что тогда?

Если вы вдруг зафиксируете объект, который имеет такое же значение SHA-1, как и предыдущий объект в вашем репозитории, Git увидит этот предыдущий объект в своей базе и посчитает, что он уже был записан.
Если вы позже попытаетесь переключиться на этот объект, то вы всегда будете получать данные первого объекта.

Однако, вы должны осознавать, насколько маловероятен такой сценарий.
Длина SHA-1 составляет 20 байт или 160 бит.
Количество случайно хешированных объектов, необходимых для достижения 50% вероятности возникновения коллизии, равно примерно 2^80^.
(формула для определения вероятности возникновения коллизии `p = (n(n-1)/2) * (1/2^160))`.
2^80^ -- это 1.2 × 10^24^, или 1 миллион миллиардов миллиардов, что в 1200 раз больше количества песчинок на земле.

Приведём пример, чтобы дать вам представление, чего будет стоить получение коллизии SHA-1.
Если бы все 6.5 миллиардов человек на Земле были программистами, и ежесекундно каждый из них производил количество кода, эквивалентное всей истории ядра Linux (3.6 миллиона Git-объектов), и отправлял его в один огромный Git репозитории, то потребовалось бы около 2 лет, пока этот репозиторий накопил бы количество объектов, достаточное для 50% вероятности возникновения SHA-1 коллизии.
Более вероятно, что каждый член вашей команды в одну и туже ночь будет атакован и убит волками в несвязанных друг с другом происшествиях.
====

[[r_branch_references]]
==== Ссылки на ветки

Для наиболее простого способа указать коммит требуется существование ветки, указывающей на этот коммит.
Тогда вы можете использовать имя ветки в любой команде Git, которая ожидает коммит или значение SHA-1.
Например, если вы хотите просмотреть последний коммит в ветке, то следующие команды эквивалентны (предполагается, что ветка `topic1` указывает на коммит `ca82a6d`):

[source,console]
----
$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1
----

Если вы хотите узнать SHA-1 объекта, на который указывает ветка, или увидеть к чему сводятся все примеры в терминах SHA-1, то вы можете воспользоваться служебной командой Git, называемой `rev-parse`.
Вы можете прочитать <<ch10-git-internals#ch10-git-internals>> для получения дополнительной информации о служебных командах;  в общем, команда `rev-parse` существует для низкоуровневых операций и не предназначена для ежедневного использования.
Однако она может быть полезна, когда вам нужно увидеть, что в действительности происходит.
Теперь вы можете выполнить `rev-parse` для вашей ветки.

[source,console]
----
$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
----

[[r_git_reflog]]
==== RefLog-сокращения

Одна из вещей, которую Git выполняет в фоновом режиме, пока вы работаете -- это ведение «журнала ссылок» -- журнала, в котором за последние несколько месяцев сохраняется то, куда указывали HEAD и ветки.

Вы можете просмотреть свой журнал ссылок, используя команду `git reflog`:

[source,console]
----
$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
----

Каждый раз когда по каким-то причинам изменяется вершина вашей ветки, Git сохраняет информацию об этом в эту временную историю.
И вы можете указывать старые коммиты, используя эти данные.
Если вы хотите увидеть какой была HEAD вашего репозитория пять шагов назад, то вы можете использовать ссылку `@{n}`, которую вы видели в выводе `reflog`:

[source,console]
----
$ git show HEAD@{5}
----

Вы можете также использовать такой синтаксис, чтобы увидеть где была ветка некоторое время назад.
Например, чтобы увидеть где была ветка `master` вчера, вы можете использовать следующую команду:

[source,console]
----
$ git show master@{yesterday}
----

Она покажет вам, где была вчера верхушка ветки.
Такой способ работает только для данных, которые всё ещё содержатся в вашем журнале ссылок, поэтому вы не можете использовать её для коммитов, которые старше нескольких месяцев.

Для просмотра журнала ссылок в формате, похожем на вывод `git log`, вы можете выполнить `git log -g`:

[source,console]
----
$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

Важно отметить, что информация в журнале ссылок строго локальная -- это лог того, что вы делали в вашем репозитории.
Ссылки не будут такими же в других копиях репозитория; а сразу после первоначального клонирования репозитория, у вас будет пустой журнал ссылок, так как никаких действий в вашем репозитории пока не производилось.
Команда `git show HEAD@{2.months.ago}` будет работать только если вы клонировали проект по крайней мере два месяца назад -- если вы клонировали его пять минут назад, то не получите никаких результатов.

==== Ссылки на предков

Ещё один популярный способ указать коммит -- это использовать её родословную.
Если вы поместите `^` в конце ссылки, Git поймёт, что нужно использовать родителя этого коммита.
Предположим, история вашего проекта выглядит следующим образом:

[source,console]
----
$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list
----

Тогда вы можете просмотреть предыдущий коммит, указав `HEAD^`, что означает «родитель HEAD»:

[source,console]
----
$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

Также вы можете указать число после `^` -- например, `d921970^2` означает «второй родитель коммита d921970».
Такой синтаксис полезен только для коммитов слияния, которые имеют больше одного родителя.
Первым родителем является ветка, в которую вы выполняли слияние, а вторым -- коммит в ветке, которую вы сливали:

[source,console]
----
$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly <paul+git@mjr.org>
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes
----

Второе важное обозначение для указания предков это `~`.
Оно также ссылается на первого родителя, поэтому `HEAD~` и `HEAD^` эквивалентны.
Различия становятся заметными, когда вы указываете число.
`HEAD~2` означает «первый родитель первого родителя» или «прадедушка» -- переход к первому родителю осуществляется столько раз, сколько вы указали.
Например, для показанной ранее истории, коммитом `HEAD~3` будет

[source,console]
----
$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

Тоже самое можно записать как `HEAD^^^`, что также является первым родителем первого родителя первого родителя:

[source,console]
----
$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

Вы также можете совмещать эти обозначения -- можно получить второго родителя предыдущей ссылки (предполагается, что это коммит слияния) используя запись `HEAD~3^2`, и так далее.

[[r_commit_ranges]]
==== Диапазоны коммитов

Теперь вы умеете указывать отдельные коммиты, давайте посмотрим как указывать диапазоны коммитов.
Это в частности полезно для управления вашими ветками -- если у вас есть множество веток, вы можете использовать указание диапазонов коммитов для ответа на вопрос «Что было сделано в этой ветке, что я ещё не слил в основную ветку?»

===== Две точки

Наиболее часто для указания диапазона коммитов используется синтаксис с двумя точками.
Таким образом, вы, по сути, просите Git включить в диапазон коммитов только те, которые достижимы из одной, но не достижимы из другой.
Для примера предположим, что ваша история выглядит, как представлено на <<rdouble_dot>>.

[[rdouble_dot]]
.Пример истории для выбора диапазонов коммитов
image::images/double-dot.png["Пример истории для выбора диапазонов коммитов"]

Вы хотите посмотреть что находится в вашей экспериментальной ветке, которая ещё не была слита в основную.
Вы можете попросить Git отобразить в логе только такие коммиты, используя запись `master..experiment` -- она означает «все коммиты, которые доступны из ветки `experiment`, но не доступны из ветки `master`».
Для краткости и наглядности в этих примерах вместо настоящего вывода лога мы будем использовать для коммитов их буквенные обозначения из диаграммы, располагая их в должном порядке:

[source,console]
----
$ git log master..experiment
D
C
----

С другой стороны, если вы хотите наоборот увидеть все коммиты ветки `master`, которых нет в ветке `experiment`, вы можете поменять имена веток в команде.
При использовании записи `experiment..master` будут отображены все коммиты ветки `master`, недоступные из ветки `experiment`:

[source,console]
----
$ git log experiment..master
F
E
----

Это полезно если вы хотите сохранить ветку `experiment` в актуальном состоянии и просмотреть, какие изменения нужно в нее слить.
Другое частое использование такого синтаксиса -- просмотр того, что будет отправлено в удалённый репозиторий.

[source,console]
----
$ git log origin/master..HEAD
----

Такая команда покажет вам все коммиты вашей текущей ветки, которые отсутствуют в ветке `master` удалённого репозитория `origin`.
Если вы выполните `git push`, находясь на ветке, отслеживающей `origin/master`, то коммиты, отображённые командой `git log origin/master..HEAD`, будут теми коммитами, которые отправятся на сервер.
Вы также можете опустить одну из частей в такой записи, Git будет считать её равной HEAD.
Например, вы можете получить такой же результат как в предыдущем примере, выполнив `git log origin/master..` -- Git подставит HEAD, если одна часть отсутствует.

===== Множество точек

Запись с двумя точками полезна как сокращение, но, возможно, вы захотите использовать более двух веток для указания нужной ревизии, например, для того, чтобы узнать какие коммиты присутствуют в любой из нескольких веток, но отсутствуют в ветке, в которой вы сейчас находитесь.
Git позволяет сделать это, используя символ `^` или опцию `--not`, перед любой ссылкой, доступные коммиты из которой вы не хотите видеть.
Таким образом, следующие три команды эквивалентны:

[source,console]
----
$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
----

Этот синтаксис удобен, так как позволяет указывать в запросе более двух ссылок, чего не позволяет сделать синтаксис с двумя точками.
Например, если вы хотите увидеть все коммиты, доступные из `refA` и `refB`, но не доступные из `refC`, вы можете использовать одну из следующих команд:

[source,console]
----
$ git log refA refB ^refC
$ git log refA refB --not refC
----

Это делает систему запросов ревизий более мощной и должно помочь вам лучше понять, что содержится в вашей ветке.

[[r_triple_dot]]
===== Три точки

Последний основной способ выбора ревизий -- это синтаксис с тремя точками, который обозначает все коммиты, доступные хотя бы из одной ссылки, но не из обеих сразу.
Вспомните пример истории коммитов в <<rdouble_dot>>.
Если вы хотите узнать какие коммиты есть либо в ветке `master`, либо в `experiment`, но не в обеих сразу, вы можете выполнить:

[source,console]
----
$ git log master...experiment
F
E
D
C
----

Эта команда снова выводит обычный журнал коммитов, но в нем содержится информация только об этих четырёх коммитах, традиционно отсортированная по дате коммитов.

В таких случаях с командой `log` часто используют опцию `--left-right`, которая отображает сторону диапазона, с которой был сделан каждый из коммитов.
Это делает данную информацию более полезной:

[source,console]
----
$ git log --left-right master...experiment
< F
< E
> D
> C
----

С помощью этих инструментов, вам будет намного проще указать Git какой коммит или коммиты вы хотите изучить.

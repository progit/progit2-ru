[[r_git_stashing]]
=== Припрятывание и очистка

Часто пока вы работаете над одной частью вашего проекта и всё находится в беспорядке, у вас возникает желание сменить ветку и поработать над чем-то ещё.
Сложность при этом заключается в том, что вы не хотите фиксировать наполовину сделанную работу только для того, чтобы иметь возможность вернуться к ней позже.
Справиться с ней помогает команда `git stash`.

Операция `stash` берёт изменённое состояние вашего рабочего каталога, то есть изменённые отслеживаемые файлы и проиндексированные изменения, и сохраняет их в хранилище незавершённых изменений, которые вы можете в любое время применить обратно.

[NOTE]
.Переход на `git stash push`
====
В конце октября 2017 года в списке рассылки Git проходило обширное обсуждение, по итогам которого команда `git stash save` признана устаревшей в пользу существующей альтернативы `git stash push`.
Основная причина этого заключается в том, что в `git stash push` есть возможность сохранить выбранные _спецификации пути_, что не поддерживает `git stash save`.

Команда `git stash save` не исчезнет в ближайшее время, поэтому не беспокойтесь о её внезапной пропаже.
Но вы можете начать переход на `push` для использования новой функциональности.
====

==== Припрятывание ваших наработок

Для примера, предположим, что вы перешли в свой проект, начали работать над несколькими файлами и, возможно, добавили в индекс изменения одного из них.
Если вы выполните `git status`, то увидите ваше изменённое состояние:

[source,console]
----
$ git status
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb
----

Теперь вы хотите сменить ветку, но пока не хотите фиксировать ваши текущие наработки; поэтому вы припрячете эти изменения.
Для того, чтобы припрятать изменение в выделенное для этого специальное хранилище, выполните `git stash` или `git stash push`:

[source,console]
----
$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 Create index file"
HEAD is now at 049d078 Create index file
(To restore them type "git stash apply")
----

Теперь вы можете увидеть, что рабочая копия не содержит изменений:

[source,console]
----
$ git status
# On branch master
nothing to commit, working directory clean
----

В данный момент вы можете легко переключать ветки и работать в любой; ваши изменения сохранены.
Чтобы посмотреть список припрятанных изменений, вы можете использовать `git stash list`:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 Create index file
stash@{1}: WIP on master: c264051 Revert "Add file_size"
stash@{2}: WIP on master: 21d80a5 Add number to log
----

В данном примере, предварительно были припрятаны два изменения, поэтому теперь вам доступны три различных отложенных наработки.
Вы можете применить только что припрятанные изменения, используя команду, указанную в выводе исходной команды: `git stash apply`.
Если вы хотите применить одно из предыдущих припрятанных изменений, вы можете сделать это, используя его имя, вот так: `git stash apply stash@{2}`.
Если вы не укажете имя, то Git попытается восстановить самое последнее припрятанное изменение:

[source,console]
----
$ git stash apply
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   index.html
	modified:   lib/simplegit.rb

no changes added to commit (use "git add" and/or "git commit -a")
----

Как видите, Git восстановил в файлах изменения, которые вы отменили ранее, когда прятали свои наработки.
В данном случае при применении отложенных наработок ваш рабочий каталог был без изменений, а вы пытались применить их в той же ветке, в которой вы их и сохранили; но отсутствие изменений в рабочем каталоге и применение их в той же ветке не являются необходимыми условиями для успешного восстановления припрятанных наработок.
Вы можете припрятать изменения, находясь в одной ветке, а затем переключиться на другую и попробовать восстановить эти изменения.
Также при восстановлении припрятанных наработок в вашем рабочем каталоге могут присутствовать изменённые и незафиксированные файлы -- Git выдаст конфликты слияния, если не сможет восстановить какие-то наработки.

Спрятанные изменения будут применены к вашим файлам, но файлы, которые вы ранее добавляли в индекс, не будут добавлены туда снова.
Для того, чтобы это было сделано, вы должны запустить `git stash apply` с опцией `--index`, при которой команда попытается восстановить изменения в индексе.
Если вы выполните команду таким образом, то полностью восстановите ваше исходное состояние:

[source,console]
----
$ git stash apply --index
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb
----

Команда `apply` только пытается восстановить припрятанные наработки -- при этом они останутся в хранилище.
Для того, чтобы удалить их, вы можете выполнить `git stash drop`, указав имя удаляемых изменений:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 Create index file
stash@{1}: WIP on master: c264051 Revert "Add file_size"
stash@{2}: WIP on master: 21d80a5 Add number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
----

Вы также можете выполнить `git stash pop`, чтобы применить припрятанные изменения и тут же удалить их из хранилища.

==== Необычное припрятывание

У припрятанных изменений есть несколько дополнительных вариантов использования, которые также могут быть полезны.
Первый -- это использование довольно популярной опции `--keep-index` с командой `git stash`.
Она просит Git не только припрятать то, что вы уже добавили в индекс, но одновременно оставить это в индексе.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html
----

Другой распространённый вариант, который вы, возможно, захотите использовать -- это припрятать помимо отслеживаемых файлов также и неотслеживаемые.
По умолчанию `git stash` будет сохранять только изменённые и проиндексированные _отслеживаемые_ файлы.
Если вы укажете опцию `--include-untracked` или `-u`, Git также припрячет все неотслеживаемые файлы, которые вы создали.
Однако включение этой опции по-прежнему не будет прятать файлы с явным игнорированием; чтобы дополнительно припрятать игнорируемые файлы, используйте `--all` (или просто `-a`).

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
$
----

И наконец, если вы укажете флаг `--patch`, Git не будет ничего прятать, а вместо этого в интерактивном режиме спросит вас о том, какие из изменений вы хотите припрятать, а какие оставить в вашем рабочем каталоге.

[source,console]
----
$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2>&1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file
----

==== Создание ветки из припрятанных изменений

Если вы спрятали некоторые изменения, оставили их на время, а сами продолжили работать в той же ветке, у вас могут возникнуть проблемы с восстановлением наработок.
Если восстановление будет затрагивать файл, который уже был изменён с момента сохранения наработок, то вы получите конфликт слияния и должны будете попытаться разрешить его.
Если вам нужен более простой способ снова протестировать припрятанные изменения, вы можете выполнить команду `git stash branch`, которая создаст для вас новую ветку, перейдёт на коммит, на котором вы были, когда прятали свои наработки, применит на нём эти наработки и затем, если они применились успешно, удалит эти припрятанные изменения:

[source,console]
----
$ git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch 'testchanges'
On branch testchanges
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)
----

Это удобное сокращение для того, чтобы легко восстановить припрятанные изменения и поработать над ними в новой ветке.

[[r_git_clean]]
==== Очистка рабочего каталога

Наконец, у вас может возникнуть желание не прятать некоторые из изменений или файлов в вашем рабочем каталоге, а просто избавиться от них.
Команда `git clean` сделает это для вас.

Одной из распространённых причин для этого может быть удаление мусора, который был сгенерирован при слиянии или внешними утилитами, или удаление артефактов сборки в процессе её очистки.

Вам нужно быть очень аккуратными с этой командой, так как она предназначена для удаления неотслеживаемых файлов из вашего рабочего каталога.
Даже если вы передумаете, очень часто нельзя восстановить содержимое таких файлов.
Более безопасным вариантом является использование команды `git stash --all` для удаления всего, но с сохранением этого в виде припрятанных изменений.

Предположим, вы хотите удалить мусор и очистить ваш рабочий каталог; вы можете сделать это с помощью `git clean`.
Для удаления всех неотслеживаемых файлов в вашем рабочем каталоге, вы можете выполнить команду `git clean -f -d`, которая удалит все файлы и также все каталоги, которые в результате станут пустыми.
Параметр `-f` (сокращение от слова force -- заставить) означает принудительное удаление, подчёркивая, что вы действительно хотите это сделать, и требуется, если переменная конфигурации Git `clean.requireForce` явным образом не установлена в `false`.

Если вы хотите только посмотреть, что будет сделано, вы можете запустить команду с опцией `-n`, которая означает «имитируй работу команды и скажи мне, что ты _будешь_ удалять».

[source,console]
----
$ git clean -d -n
Would remove test.o
Would remove tmp/
----

По умолчанию команда `git clean` будет удалять только неотслеживаемые файлы, которые не добавлены в список игнорируемых.
Любой файл, который соответствует шаблону в вашем `.gitignore`, или другие игнорируемые файлы не будут удалены.
Если вы хотите удалить и эти файлы (например, удалить все `.o`-файлы, генерируемые в процессе сборки, и таким образом полностью очистить сборку), вы можете передать команде очистки опцию `-x`.

[source,console]
----
$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/
----

Если вы не знаете, что сделает при запуске команда `git clean`, всегда сначала выполняйте её с опцией `-n`, чтобы проверить дважды, перед заменой `-n` на `-f` и выполнением настоящей очистки.
Другой способ, который позволяет вам более тщательно контролировать сам процесс -- это выполнение команды с опцией `-i` (в «интерактивном» режиме).

Ниже выполнена команда очистки в интерактивном режиме.

[source,console]
----
$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now>
----

Таким образом, вы можете просмотреть каждый файл индивидуально или указать шаблоны для удаления в интерактивном режиме.

[NOTE]
====
Существует причудливая ситуация, когда вам, возможно, придётся проявить особую настойчивость, попросив Git очистить ваш рабочий каталог.
Если вы оказались в рабочем каталоге, в который вы скопировали или клонировали другие репозитории Git (возможно, в виде подмодулей), даже `git clean -fd` откажется удалить эти каталоги.
В таких случаях вам нужно добавить второй параметр `-f` для акцентирования.
====

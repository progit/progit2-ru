[[r_git_config]]
=== Конфигурация Git

(((git commands, config)))
В разделе <<ch01-introduction#ch01-introduction>> кратко упоминалось, что вы можете настроить гит используя команду `git config`.
Первое, что вы делали, это установили своё имя и e-mail адрес:

[source,console]
----
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
----

Сейчас вы познакомитесь с несколькими наиболее интересными опциями, которые можно установить для настройки поведения Git.

Кратко: Git использует набор конфигурационных файлов для изменения стандартного поведения, если это необходимо.
Вначале, Git ищет настройки в файле `/etc/gitconfig`, который содержит настройки для всех пользователей в системе и всех репозиториев.
Если передать опцию `--system` команде `git config`, то операции чтения и записи будут производиться именно с этим файлом.

Следующее место, куда смотрит Git - это файл `~/.gitconfig` (или `~/.config/git/config`), который хранит настройки конкретного пользователя.
Вы можете указать Git читать и писать в него, используя опцию `--global`.

Наконец, Git ищет параметры конфигурации в файле настроек в директории Git (`.git/config`) используемого в данный момент репозитория.
Эти значения относятся только к текущему репозиторию.

Каждый из этих ``уровней'' (системный, глобальный, локальный) переопределяет значения предыдущего уровня, например, значения из `.git/config` важнее значений из `/etc/gitconfig`.

[NOTE]
====
Конфигурация Git это обычные текстовые файлы, поэтому можно вручную установить необходимые значения используя соответствующий синтаксис.
Как правило, это проще чем вызывать команду `git config` для каждого параметра.
====

==== Базовая конфигурация клиента

Конфигурационные параметры Git разделяются на две категории: настройки клиента и настройки сервера.
Большая часть - клиентские, для настройки ваших лмчных предпочтений в работе.
Существует много, _очень мого_ настроек, но подавляющее большинство из них применимо только в конкретных случаях.
Мы рассмотрим только самые основные и самые полезные из них.
Для просмотра полного списка настроек, поддерживаемых вашей версией Git, выполните команду:

[source,console]
----
$ man git-config
----

Эта команда выведет список доступных настроек с довольно подробным описанием.
Так же, соответствующую документацию можно найти здесь http://git-scm.com/docs/git-config.html[].

===== `core.editor`

((($EDITOR)))((($VISUAL, see $EDITOR)))
По умолчанию, Git использует ваш редактор по умолчанию (`$VISUAL` или `$EDITOR`), если значение не задано - переходит к использованию редактора `vi` при создании и редактировании сообщений коммитов или тэгов.
Чтобы изменить редактор по умолчанию, воспользуйтесь настройкой `core.editor`:

[source,console]
----
$ git config --global core.editor emacs
----

Теперь, вне зависимости от того, какой редактор является основным для вашего окружения, Git будет вызывать `Emacs` для редактирования сообщений.

===== `commit.template`

(((commit templates)))
Если указать путь к существующему файлу, то он будет использован как сообщение по умолчанию при создании коммита.
Например, предположим что вы создали файл `~/.gitmessage.txt`, который выглядит так:

[source]
----
subject line

what happened

[ticket: X]
----

Чтобы заставить Git отображать содержимое этого файла в редакторе каждый раз при выполнении команды `git commit`, следует установить значение параметра `commit.template`:

[source,console]
----
$ git config --global commit.template ~/.gitmessage.txt
$ git commit
----

Теперь, при создании коммита, в вашем редакторе будет отображаться сообщение измененного вида:

[source]
----
subject line

what happened

[ticket: X]
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
# modified:   lib/test.rb
#
~
~
".git/COMMIT_EDITMSG" 14L, 297C
----

Если ваша команда придерживается требований к сообщениям коммитов, то создание шаблона такого сообщения и настройка Git на его использование увеличит вероятность соответствия заданным требованиям.

===== `core.pager`

(((pager)))
Данная настройка определяет какая программа будет использована для разбиения текста на страницы при выводе такой информации как `log` и `diff`.
Вы можете указать `more` или любую другую (по умолчанию используется `less`), а так же выключить совсем, установив пустое зачение:

[source,console]
----
$ git config --global core.pager ''
----

В таком случае, Git будет выводить весь текст полностью, вне зависимости от его длинны.

===== `user.signingkey`

(((GPG)))
Если вы создаёте подписанные аннотированные тэги (как описано в разделе <<ch07-git-tools#r_signing>>), то установка GPG ключа в настройках облегчит вам задачу.
Установить ключ можно следующим образом:

[source,console]
----
$ git config --global user.signingkey <gpg-key-id>
----

Теперь, вам не нужно указывать ключ для подписи каждый раз при вызове команды `git tag`:

[source,console]
----
$ git tag -s <tag-name>
----

===== `core.excludesfile`

(((excludes)))(((.gitignore)))
В разделе <<ch02-git-basics#r_ignoring>> сказано, что вы можете указывать шаблоны исключений в файле `.gitignore` вашего проекта, чтобы Git не отслеживал их и не добавлял в индекс при выполнении команды `git add`.

Однако, иногда вам нужно игнорировать определенные файлы во всех ваших репозиториях.
Если на вашем компьютере работает Mac OS X, вероятно вы закомы с файлами `.DS_Store`.
Если вы используете Emacs или Vim, то вы знаете про файлы, имена которых заканчиваются символом `~`.

Данная настройка позволяет вам определить что-то вроде глобального файла `.gitignore`.
Если вы создадите файл `~/.gitignore_global` с содержанием:

[source]
----
*~
.DS_Store
----

… и выполните команду `git config --global core.excludesfile ~/.gitignore_global`, то Git больше не потревожит вас на счёт этих файлов.

===== `help.autocorrect`

(((autocorrect)))
Если вы ошибётесь в написании команды, Git покажет вам что-то вроде этого:

[source,console]
----
$ git chekcout master
git: 'chekcout' is not a git command. See 'git --help'.

Did you mean this?
    checkout
----

Git старается угадать, что вы имели ввиду, но при этом команду не выполняет.
Если вы установите `help.autocorrect` в значение 1, то Git будет выполнять эту команду:

[source,console]
----
$ git chekcout master
WARNING: You called a Git command named 'chekcout', which does not exist.
Continuing under the assumption that you meant 'checkout'
in 0.1 seconds automatically...
----

Обратите внимание, что команда выполнилась через ``0.1'' секунды. `help.autocorrect` - это число, указываемое в десятых долях секунды.
Поэтому, если вы установите значение 50, то Git даст вам 5 секунд изменить своё решение перед тем, как выполнить скорректированную команду.

==== Цвета в Git

(((color)))
Git полностью поддерживает цветовой вывод в терминале, что позволяет быстро и легко визуально анализировать вывод команд.
Существует несколько опций для настройки цветов.

===== `color.ui`

Git автоматически подсвечивает большую часть своего вывода, но это можно отключить, если вам не нравится такое поведение.
Для отключения цветового вывода в терминал, выполните следующую команду:

[source,console]
----
$ git config --global color.ui false
----

Значение по умолчанию - `auto`, при котором цвета используются при непосредственном выводе в терминал, но исключаются при перенаправлении вывода в именованный канал или файл.

Вы так же можете установить значение `always`, что делает вывод одинаковым как в терминал, так и в именованный канал.
Скорее всего, вам это не понадобится; в большинстве случаев, при желании использовать цвета в перенаправленном выводе, указывется флаг `--color` команде Git для принудительного использования цветовых кодов.
Практически всегда стандартное значение подходит лучше всего.

===== `color.*`

Если вы хотите явно указать вывод каких команд должен быть подсвечен и как, Git предоставляет соответствующие настройки.
Каждая из них может быть установлена в значения `true`, `false`, или `always`:

  color.branch
  color.diff
  color.interactive
  color.status

Каждая из них имеет вложенную конфигурацию, которую можно использовать для настройки отдельных частей вывода при желани переопределить их цвет.
Например, чтобы установить для метаинформации вывода команды diff синий цвет, чёрный фон и полужирный шрифт, выполните команду:

  $ git config --global color.diff.meta "blue black bold"

Для установки цвета доступны следующие значения: `normal`, `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, или `white`.
Для указания атрибутов текста, как `bold` в предыдущем примере, доступны значения: `bold`, `dim`, `ul` (подчеркнутый), `blink`, и `reverse` (поменять местами цвет фона и цвет текста).

[[r_external_merge_tools]]
==== Внешние программы слияния и сравнения

(((mergetool)))(((difftool)))
Хоть в Git и есть встроенная программа сравнения, которая описывается в этой книге, вы можете установить вместо неё другую.
Вы также можете настроить графический инструмент разрешения конфликтов слияния вместо того, чтобы разрешать конфликты вручную.
Мы покажем как настроить Perforce Visual Merge Tool (P4Merge) для разрешения конфликтов слияния, так как это прекрасный и бесплатный инструмент.

Если у вас есть желание попробовать P4Merge, то она работает на всех основных платформах, так что у вас должно получиться.
В примерах мы будем использовать пути к файлам, которые работают в системах Linux и Mac; для Windows вам следует изменить `/usr/local/bin` на путь к исполняемому файлу у вас в системе.

Сначала, скачайте P4Merge отсюда http://www.perforce.com/downloads/Perforce/[].
Затем, создайте скрипты обёртки для вызова внешних программ.
Мы будем использовать путь к исполняемому файлу в системе Mac; в других системах - это путь к файлу `p4merge`.
Создайте скрипт с названием `extMerge` для вызова программы слияния и передачи ей заданных параметров:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*
----

Скрипт вызова программы сравнения проверяет наличие 7 аргументов и передаёт 2 из них в скрипт вызова программы слияния.
По умолчанию, Git передаёт следующие аргументы программе сравнения:

[source]
----
path old-file old-hex old-mode new-file new-hex new-mode
----

Так как вам нужны только `old-file` и `new-file`, следует использовать скрипт, который передаст только необходимые параметры.

[source,console]
----
$ cat /usr/local/bin/extDiff
#!/bin/sh
[ $# -eq 7 ] && /usr/local/bin/extMerge "$2" "$5"
----

Так же следует убедиться, что созданные скрипты могут исполняться:

[source,console]
----
$ sudo chmod +x /usr/local/bin/extMerge
$ sudo chmod +x /usr/local/bin/extDiff
----

Теперь можно изменить файл конфигурации для использования ваших инструментов слияния и сравнения.
Для этого необходимо изменить ряд настроек: `merge.tool` - чтобы сказать Git какую стратегию использовать, `mergetool.<tool>.cmd` - чтобы сказать Git как запускать команду, `mergetool.<tool>.trustExitCode` - чтобы сказать Git как интерпретировать код выхода из программы, `diff.external` - чтобы сказать Git какую команду использовать для сравнения.
Таким образом, команду конфигурации нужно запустить четыре раза:

[source,console]
----
$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
  'extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"'
$ git config --global mergetool.extMerge.trustExitCode false
$ git config --global diff.external extDiff
----
или вручную отредактировать файл `~/.gitconfig` добавив соответствующие строки:

[source,ini]
----
[merge]
  tool = extMerge
[mergetool "extMerge"]
  cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
  trustExitCode = false
[diff]
  external = extDiff
----

После этого, вы можете запускать команды diff следующим образом:

[source,console]
----
$ git diff 32d1776b1^ 32d1776b1
----

Вместо отображения вывода diff в терминале Git запустит P4Merge, выглядеть это будет примерно так:

.P4Merge.
image::images/p4merge.png[P4Merge.]

Если при слиянии двух веток у вас возникнут конфликты, выполните команду `git mergetool`; она запустит P4Merge чтобы вы могли разрешить конфликты используя графический интерфейс.

Используя скрипт обертку для вызова внешних программ, вы можете легко изменить вызываемую программу.
Например, чтобы начать использовать KDiff3 вместо P4Merge, достаточно изменить файл `extMerge`:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*
----

Теперь, Git будет использовать программу KDiff3 для сравнения файлов и разрешения конфликтов слияния.

Git изначально настроен на использование ряда других инструментов для разрешения конфликтов слияния, поэтому вам не нужно дополнительно что-то настраивать.
Для просмотра списка поддерживаемых инструментов, выполните команду:

[source,console]
----
$ git mergetool --tool-help
'git mergetool --tool=<tool>' may be set to one of the following:
        emerge
        gvimdiff
        gvimdiff2
        opendiff
        p4merge
        vimdiff
        vimdiff2

The following tools are valid, but not currently available:
        araxis
        bc3
        codecompare
        deltawalker
        diffmerge
        diffuse
        ecmerge
        kdiff3
        meld
        tkdiff
        tortoisemerge
        xxdiff

Some of the tools listed above only work in a windowed
environment. If run in a terminal-only session, they will fail.
----

Если вы хотите использовать KDiff3 только для разрешения конфликтов слияния, но не для сравнения, выполните команду: 

[source,console]
----
$ git config --global merge.tool kdiff3
----

Если выполнить эту команду вместо настройки использования файлов `extMerge` и `extDiff`, то Git будет использовать KDiff3 для разрешения конфликтов слияния, а для сравнения - стандартную программу diff.

==== Formatting and Whitespace

(((whitespace)))
Formatting and whitespace issues are some of the more frustrating and subtle problems that many developers encounter when collaborating, especially cross-platform.
It's very easy for patches or other collaborated work to introduce subtle whitespace changes because editors silently introduce them, and if your files ever touch a Windows system, their line endings might be replaced.
Git has a few configuration options to help with these issues.

===== `core.autocrlf`

(((crlf)))(((line endings)))
If you're programming on Windows and working with people who are not (or vice-versa), you'll probably run into line-ending issues at some point.
This is because Windows uses both a carriage-return character and a linefeed character for newlines in its files, whereas Mac and Linux systems use only the linefeed character.
This is a subtle but incredibly annoying fact of cross-platform work; many editors on Windows silently replace existing LF-style line endings with CRLF, or insert both line-ending characters when the user hits the enter key.

Git can handle this by auto-converting CRLF line endings into LF when you add a file to the index, and vice versa when it checks out code onto your filesystem.
You can turn on this functionality with the `core.autocrlf` setting.
If you're on a Windows machine, set it to `true` – this converts LF endings into CRLF when you check out code:

[source,console]
----
$ git config --global core.autocrlf true
----

If you're on a Linux or Mac system that uses LF line endings, then you don't want Git to automatically convert them when you check out files; however, if a file with CRLF endings accidentally gets introduced, then you may want Git to fix it.
You can tell Git to convert CRLF to LF on commit but not the other way around by setting `core.autocrlf` to input:

[source,console]
----
$ git config --global core.autocrlf input
----

This setup should leave you with CRLF endings in Windows checkouts, but LF endings on Mac and Linux systems and in the repository.

If you're a Windows programmer doing a Windows-only project, then you can turn off this functionality, recording the carriage returns in the repository by setting the config value to `false`:

[source,console]
----
$ git config --global core.autocrlf false
----

===== `core.whitespace`

Git comes preset to detect and fix some whitespace issues.
It can look for six primary whitespace issues – three are enabled by default and can be turned off, and three are disabled by default but can be activated.

The ones that are turned on by default are `blank-at-eol`, which looks for spaces at the end of a line; `blank-at-eof`, which notices blank lines at the end of a file; and `space-before-tab`, which looks for spaces before tabs at the beginning of a line.

The three that are disabled by default but can be turned on are `indent-with-non-tab`, which looks for lines that begin with spaces instead of tabs (and is controlled by the `tabwidth` option); `tab-in-indent`, which watches for tabs in the indentation portion of a line; and `cr-at-eol`, which tells Git that carriage returns at the end of lines are OK.

You can tell Git which of these you want enabled by setting `core.whitespace` to the values you want on or off, separated by commas.
You can disable settings by either leaving them out of the setting string or prepending a `-` in front of the value.
For example, if you want all but `cr-at-eol` to be set, you can do this:

[source,console]
----
$ git config --global core.whitespace \
    trailing-space,space-before-tab,indent-with-non-tab
----

Git will detect these issues when you run a `git diff` command and try to color them so you can possibly fix them before you commit.
It will also use these values to help you when you apply patches with `git apply`.
When you're applying patches, you can ask Git to warn you if it's applying patches with the specified whitespace issues:

[source,console]
----
$ git apply --whitespace=warn <patch>
----

Or you can have Git try to automatically fix the issue before applying the patch:

[source,console]
----
$ git apply --whitespace=fix <patch>
----

These options apply to the `git rebase` command as well.
If you've committed whitespace issues but haven't yet pushed upstream, you can run `git rebase --whitespace=fix` to have Git automatically fix whitespace issues as it's rewriting the patches.

==== Server Configuration

Not nearly as many configuration options are available for the server side of Git, but there are a few interesting ones you may want to take note of.

===== `receive.fsckObjects`

Git is capable of making sure every object received during a push still matches its SHA-1 checksum and points to valid objects.
However, it doesn't do this by default; it's a fairly expensive operation, and might slow down the operation, especially on large repositories or pushes.
If you want Git to check object consistency on every push, you can force it to do so by setting `receive.fsckObjects` to true:

[source,console]
----
$ git config --system receive.fsckObjects true
----

Now, Git will check the integrity of your repository before each push is accepted to make sure faulty (or malicious) clients aren't introducing corrupt data.

===== `receive.denyNonFastForwards`

If you rebase commits that you've already pushed and then try to push again, or otherwise try to push a commit to a remote branch that doesn't contain the commit that the remote branch currently points to, you'll be denied.
This is generally good policy; but in the case of the rebase, you may determine that you know what you're doing and can force-update the remote branch with a `-f` flag to your push command.

To tell Git to refuse force-pushes, set `receive.denyNonFastForwards`:

[source,console]
----
$ git config --system receive.denyNonFastForwards true
----

The other way you can do this is via server-side receive hooks, which we'll cover in a bit.
That approach lets you do more complex things like deny non-fast-forwards to a certain subset of users.

===== `receive.denyDeletes`

One of the workarounds to the `denyNonFastForwards` policy is for the user to delete the branch and then push it back up with the new reference.
To avoid this, set `receive.denyDeletes` to true:

[source,console]
----
$ git config --system receive.denyDeletes true
----

This denies any deletion of branches or tags – no user can do it.
To remove remote branches, you must remove the ref files from the server manually.
There are also more interesting ways to do this on a per-user basis via ACLs, as you'll learn in <<r_an_example_git_enforced_policy>>.

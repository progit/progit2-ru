[[r_an_example_git_enforced_policy]]
=== Пример принудительной политики Git

(((policy example)))
В этом разделе вы сможете применить полученные знания для создания рабочего процесса Git, при котором будет проверяться формат сообщения коммита и определенным пользователям будет разрешено изменять содержимое заданных директорий проекта.
Вы создадите клиентские скрипты, которые помогут разработчикам понять, когда их изменения будут отклонены, а также серверные скрипты, которые обеспечат выполнение заданных политик.

Скрипты, которые будут приведены ниже, написаны на Ruby; отчасти по причине нашей интеллектуальной инерции, но также и потому, что Ruby легко читать, даже если вы не пишите на нём.
К слову, любой язык будет работать -- все примеры хуков, распространяемые с Git, написаны на Perl или Bash; с ними вы можете ознакомиться, посмотрев примеры.

==== Серверный Хук

На стороне сервера вся работа производится в файле `update` из директории `hooks`.
Хук `update` запускается однократно для каждой отправляемой ветки и принимает три параметра:

* Ссылка на ветку, в которую производится отправка
* Текущая ревизия ветки назначения
* Отправляемая ревизия

Так же можно получить имя пользователя, производящего отправку, если действия выполняются по протоколу SSH.
Если вы настроили аутентификацию по публичному ключу используя одного пользователя (например, ``git''), то вам потребуется использовать дополнительную обёртку командной оболочки, чтобы определить реального пользователя по его публичному ключу и правильно установить переменную окружения `$USER`.
Далее предполагается, что переменная `$USER` уже содержит имя подключившегося пользователя, поэтому скрипт `update` начинается со сбора необходимой информации:

[source,ruby]
----
#!/usr/bin/env ruby

$refname = ARGV[0]
$oldrev  = ARGV[1]
$newrev  = ARGV[2]
$user    = ENV['USER']

puts "Enforcing Policies..."
puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"
----

Да, здесь используются глобальные переменные.
Не судите строго -- это самый простой способ демонстрации.

[[r_enforcing_commit_message_format]]
===== Проверка формата сообщения коммита

Ваша первая задача -- сделать так, чтобы каждый коммит соответствовал заданному формату.
Предположим, что сообщение каждого коммита должно содержать строку вида ``ref: 1234'', так как вы хотите связать каждый коммит с соответствующим элементом в вашей системе управления задачами.
Для этого вам понадобиться проверять каждый получаемый коммит, искать в сообщении заданную подстроку и, в случае её отсутствия в сообщении любого из коммитов, прекращать обработку с ненулевым кодом, что приведёт к отклонению отправки целиком.

Вы можете получить список SHA-1 значений всех отправляемых коммитов передав значения `$newrev` и `$oldrev` низкоуровневой команде Git под названием `git rev-list`.
В действительности, это команда `git log`, которая по умолчанию выводит только список значений SHA-1 и ничего больше.
Поэтому, для получения списка SHA-1 хешей коммитов, находящихся между двумя заданными, вам следует выполнить, например, следующую команду:

[source,console]
----
$ git rev-list 538c33..d14fc7
d14fc7c847ab946ec39590d87783c69b031bdfb7
9f585da4401b0a3999e84113824d15245c13f0be
234071a1be950e2a8d078e6141f5cd20c1e61ad3
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475
----

Для каждого SHA-1 хеша из полученного результата можно получить соответствующее сообщение коммита и с помощью регулярного выражения проверить наличие искомой подстроки.

Осталось выяснить как получить сообщение коммита, зная его SHA-1 хеш.
Чтобы получить содержимое коммита, следует использовать другую низкоуровневую команду `git cat-file`.
Более детально мы рассмотрим эти низкоуровневые команды в разделе <<ch10-git-internals#ch10-git-internals>>; а сейчас покажем, что эта команда вам даёт:

[source,console]
----
$ git cat-file commit ca82a6
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon <schacon@gmail.com> 1205815931 -0700
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

changed the version number
----

Самый простой способ извлечь сообщение коммита -- это найти первую пустую строку и взять всё, что идёт после неё.
В системах Unix и Mac это можно сделать с помощью программы `sed`:

[source,console]
----
$ git cat-file commit ca82a6 | sed '1,/^$/d'
changed the version number
----

Вы можете использовать эту магическую команду для извлечения сообщения отправляемого коммита и прерывать проверку в случае, когда что-то не соответствует.
Для прерывания выполнения скрипта и отклонения отправки используйте ненулевой код возврата.
Полностью функция выглядит следующим образом:

[source,ruby]
----
$regex = /\[ref: (\d+)\]/

# enforced custom commit message format
def check_message_format
  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  missed_revs.each do |rev|
    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
    if !$regex.match(message)
      puts "[POLICY] Your message is not formatted correctly"
      exit 1
    end
  end
end
check_message_format
----

Размещение указанного кода в скрипте `update` приведет к отклонению всех обновлений, в которых содержатся один или несколько коммитов с сообщением, которое не соответствует вашему правилу.

===== Контроль доступа по списку имён пользователей

Предположим, вы хотите применить механизм контроля доступа на основе списков контроля доступа, позволяющий определенным пользователям вносить изменения в определенные части вашего проекта.
К примеру, некоторые пользователи имеют полный доступ, а другие могут изменять только определённые директории проекта или отдельные файлы.
Для реализации этого, следует записать эти правила в файл `acl`, находящийся в репозитории на сервере.
Затем обновить хук `update`, чтобы он использовал эти правила при просмотре списка файлов в отправляемых коммитах для определения наличия прав доступа ко всем этим файлам у отправляющего пользователя.

Первое, что надо сделать -- это создать список контроля доступа.
Здесь следует использовать формат, который очень похож на CVS и представляет собой список строк, в каждой из которых первое поле имеет значение `avail` или `unavail`, второе поле содержит список пользователей, разделённых запятой, а третье поле -- это путь к файлу или директории, для которого применяется это правило (пустое значение подразумевает отсутствие ограничения).
В качестве разделителя для этих полей применяется вертикальная черта (`|`).

В случае, когда у вас есть группа администраторов, несколько технических писателей с доступом к директории `doc` и один разработчик, у которого есть доступ только к директориям `lib` и `tests`, файл со списком контроля доступа будет выглядеть так:

[source]
----
avail|nickh,pjhyett,defunkt,tpw
avail|usinclair,cdickens,ebronte|doc
avail|schacon|lib
avail|schacon|tests
----

Для начала нужно прочитать эти данные и сформировать структуры для дальнейшего использования.
С целью упрощения здесь мы используем только директивы `avail`.
Ниже представлен метод, который возвращает ассоциативный массив, в котором ключом является имя пользователя, а значением -- массив путей, к которым пользователь имеет доступ на запись.

[source,ruby]
----
def get_acl_access_data(acl_file)
  # read in ACL data
  acl_file = File.read(acl_file).split("\n").reject { |line| line == '' }
  access = {}
  acl_file.each do |line|
    avail, users, path = line.split('|')
    next unless avail == 'avail'
    users.split(',').each do |user|
      access[user] ||= []
      access[user] << path
    end
  end
  access
end
----

Для представленного ранее файла списка контроля доступа этот метод вернёт следующую структуру данных:

[source,ruby]
----
{"defunkt"=>[nil],
 "tpw"=>[nil],
 "nickh"=>[nil],
 "pjhyett"=>[nil],
 "schacon"=>["lib", "tests"],
 "cdickens"=>["doc"],
 "usinclair"=>["doc"],
 "ebronte"=>["doc"]}
----

Теперь, когда вопрос с правами доступа решён, необходимо извлечь список путей, изменения по которым присутствуют в отправляемых коммитах, чтобы убедиться в наличии доступа к ним у отправляющего пользователя.

Список файлов одного коммита можно легко получить, используя опцию `--name-only` команды `git log` (кратко рассматривалось в Главе 2):

[source,console]
----
$ git log -1 --name-only --pretty=format:'' 9f585d

README
lib/test.rb
----

Если воспользоваться структурой данных, полученной методом `get_acl_access_data`, и проверить соответствие путей из каждого коммита на соответствие ей, то можно определить наличие прав доступа у пользователя на отправку всех коммитов:

[source,ruby]
----
# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('acl')

  # see if anyone is trying to push something they can't
  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  new_commits.each do |rev|
    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split("\n")
    files_modified.each do |path|
      next if path.size == 0
      has_file_access = false
      access[$user].each do |access_path|
        if !access_path  # user has access to everything
           || (path.start_with? access_path) # access to this path
          has_file_access = true
        end
      end
      if !has_file_access
        puts "[POLICY] You do not have access to push to #{path}"
        exit 1
      end
    end
  end
end

check_directory_perms
----

В результате, вы получаете список отправляемых коммитов командой `git rev-list`.
Затем для каждого коммита извлекаете список файлов и проверяете наличие прав доступа у отправляющего пользователя на их изменение.

Теперь ваши пользователи не смогут отправить коммиты с плохо оформленными сообщениями или содержащие изменения в файлах, находящихся за пределами заданных путей.

===== Тестирование

Если выполнить `chmod u+x .git/hooks/update` для файла, в который вам следует поместить весь приведённый выше код, и попытаетесь отправить плохо оформленный коммит, то получите приблизительно следующее сообщение:

[source,console]
----
$ git push -f origin master
Counting objects: 5, done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 323 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
Enforcing Policies...
(refs/heads/master) (8338c5) (c5b616)
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
To git@gitserver:project.git
 ! [remote rejected] master -> master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
----

Здесь стоит обратить внимание на несколько интересных моментов.
Первое -- это момент начала работы хука.

[source]
----
Enforcing Policies...
(refs/heads/master) (fb8c72) (c56860)
----

Как вы помните, эти строки вы выводите в самом начале скрипта `update`.
Всё, что ваш скрипт выводит в `stdout`, будет передано клиенту.

Второе, на что следует обратить внимание, это сообщение об ошибке.

[source]
----
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
----

Первая строка -- это ваше сообщение, две другие добавляет Git сообщая, что скрипт `update` завершился с ненулевым кодом, что привело к отклонению отправки.
Ну и наконец, у вас есть вот это:

[source]
----
To git@gitserver:project.git
 ! [remote rejected] master -> master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
----

Здесь можно увидеть сообщение об отказе для каждой из веток, которые отклонил ваш хук, при этом будет явно указано, что именно он является причиной отказа.

Более того, если кто-то отредактирует файл, на изменение которого у него нет прав, и попытается отправить содержащий это изменение коммит, то получит аналогичное сообщение.
Например, если технический писатель попытается отправить коммит, содержащий изменения в директории `lib`, то он увидит следующее:

[source]
----
[POLICY] You do not have access to push to lib/test.rb
----

С момента как скрипт `update` существует и исполняем, ваш репозиторий не будет содержать коммиты с сообщением, неудовлетворяющем установленному шаблону, а доступ ваших пользователей будет ограничен.

==== Client-Side Hooks

The downside to this approach is the whining that will inevitably result when your users' commit pushes are rejected.
Having their carefully crafted work rejected at the last minute can be extremely frustrating and confusing; and furthermore, they will have to edit their history to correct it, which isn't always for the faint of heart.

The answer to this dilemma is to provide some client-side hooks that users can run to notify them when they're doing something that the server is likely to reject.
That way, they can correct any problems before committing and before those issues become more difficult to fix.
Because hooks aren't transferred with a clone of a project, you must distribute these scripts some other way and then have your users copy them to their `.git/hooks` directory and make them executable.
You can distribute these hooks within the project or in a separate project, but Git won't set them up automatically.

To begin, you should check your commit message just before each commit is recorded, so you know the server won't reject your changes due to badly formatted commit messages.
To do this, you can add the `commit-msg` hook.
If you have it read the message from the file passed as the first argument and compare that to the pattern, you can force Git to abort the commit if there is no match:

[source,ruby]
----
#!/usr/bin/env ruby
message_file = ARGV[0]
message = File.read(message_file)

$regex = /\[ref: (\d+)\]/

if !$regex.match(message)
  puts "[POLICY] Your message is not formatted correctly"
  exit 1
end
----

If that script is in place (in `.git/hooks/commit-msg`) and executable, and you commit with a message that isn't properly formatted, you see this:

[source,console]
----
$ git commit -am 'test'
[POLICY] Your message is not formatted correctly
----

No commit was completed in that instance.
However, if your message contains the proper pattern, Git allows you to commit:

[source,console]
----
$ git commit -am 'test [ref: 132]'
[master e05c914] test [ref: 132]
 1 file changed, 1 insertions(+), 0 deletions(-)
----

Next, you want to make sure you aren't modifying files that are outside your ACL scope.
If your project's `.git` directory contains a copy of the ACL file you used previously, then the following `pre-commit` script will enforce those constraints for you:

[source,ruby]
----
#!/usr/bin/env ruby

$user    = ENV['USER']

# [ insert acl_access_data method from above ]

# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('.git/acl')

  files_modified = `git diff-index --cached --name-only HEAD`.split("\n")
  files_modified.each do |path|
    next if path.size == 0
    has_file_access = false
    access[$user].each do |access_path|
    if !access_path || (path.index(access_path) == 0)
      has_file_access = true
    end
    if !has_file_access
      puts "[POLICY] You do not have access to push to #{path}"
      exit 1
    end
  end
end

check_directory_perms
----

This is roughly the same script as the server-side part, but with two important differences.
First, the ACL file is in a different place, because this script runs from your working directory, not from your `.git` directory.
You have to change the path to the ACL file from this

[source,ruby]
----
access = get_acl_access_data('acl')
----

to this:

[source,ruby]
----
access = get_acl_access_data('.git/acl')
----

The other important difference is the way you get a listing of the files that have been changed.
Because the server-side method looks at the log of commits, and, at this point, the commit hasn't been recorded yet, you must get your file listing from the staging area instead.
Instead of

[source,ruby]
----
files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`
----

you have to use

[source,ruby]
----
files_modified = `git diff-index --cached --name-only HEAD`
----

But those are the only two differences -- otherwise, the script works the same way.
One caveat is that it expects you to be running locally as the same user you push as to the remote machine.
If that is different, you must set the `$user` variable manually.

One other thing we can do here is make sure the user doesn't push non-fast-forwarded references.
To get a reference that isn't a fast-forward, you either have to rebase past a commit you've already pushed up or try pushing a different local branch up to the same remote branch.

Presumably, the server is already configured with `receive.denyDeletes` and `receive.denyNonFastForwards` to enforce this policy, so the only accidental thing you can try to catch is rebasing commits that have already been pushed.

Here is an example pre-rebase script that checks for that.
It gets a list of all the commits you're about to rewrite and checks whether they exist in any of your remote references.
If it sees one that is reachable from one of your remote references, it aborts the rebase.

[source,ruby]
----
#!/usr/bin/env ruby

base_branch = ARGV[0]
if ARGV[1]
  topic_branch = ARGV[1]
else
  topic_branch = "HEAD"
end

target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split("\n")
remote_refs = `git branch -r`.split("\n").map { |r| r.strip }

target_shas.each do |sha|
  remote_refs.each do |remote_ref|
    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
    if shas_pushed.split("\n").include?(sha)
      puts "[POLICY] Commit #{sha} has already been pushed to #{remote_ref}"
      exit 1
    end
  end
end
----
This script uses a syntax that wasn't covered in the Revision Selection section of Chapter 6. You get a list of commits that have already been pushed up by running this:

[source,ruby]
----
`git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
----

The `SHA^@` syntax resolves to all the parents of that commit.
You're looking for any commit that is reachable from the last commit on the remote and that isn't reachable from any parent of any of the SHA-1s you're trying to push up -- meaning it's a fast-forward.

The main drawback to this approach is that it can be very slow and is often unnecessary -- if you don't try to force the push with `-f`, the server will warn you and not accept the push.
However, it's an interesting exercise and can in theory help you avoid a rebase that you might later have to go back and fix.

=== Уход за репозиторием и восстановление данных

Изредка вам потребуется делать "уборку" -- сделать репозиторий более компактным, очистить импортированный репозиторий от лишних файлов или восстановить потерянные данные.
Данный раздел охватывает некоторые из этих сценариев.

[[r_git_gc]]
==== Уход за репозиторием

Время от времени Git выполняет автоматическую сборку мусора.
Чаще всего эта команда ничего не делает.
Однако, если у вас накопилось слишком много "рыхлых" объектов (не в pack-файлах), или, наоборот, отдельных pack-файлов, Git запускает полноценный сборщик -- `git gc`.
Здесь "gc" это сокращение от "garbage collect", что означает "сборка мусора".
Эта команда выполняет несколько действий: собирает все рыхлые объекты и упаковывает их в pack-файлы; объединяет несколько упакованных файлов в один большой; удаляет недостижимые объекты, хранящиеся дольше нескольких месяцев.

Можно запустить сборку мусора вручную:

[source,console]
----
$ git gc --auto
----

Опять же, как правило, эта команда ничего не делает.
Нужно иметь примерно 7000 несжатых объектов или более 50 pack-файлов, чтобы запустился настоящий gc.
Эти значения можно изменить с помощью параметров `gc.auto` и `gc.autopacklimit` соответственно.

Ещё одно действие, выполняемое gc -- упаковка ссылок в единый файл.
Предположим, репозиторий содержит следующие ветки и теги:

[source,console]
----
$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1
----

Если выполнить `git gc`, эти файлы будут удалены из директории `refs`.
Git перенесёт их в файл `.git/packed-refs` в угоду эффективности:

[source,console]
----
$ cat .git/packed-refs
# pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9
----

При обновлении ссылки Git не будет редактировать этот файл, а добавит новый файл в `refs/heads`.
Для получения хеша, соответствующего нужной ссылке, Git сначала проверит наличие файла ссылки в директории `refs`, а к файлу `packed-refs` обратится только в случае отсутствия оного.
Так что, если вы не можете найти ссылку в директории `refs`, скорее всего она упакована в файле `packed-refs`.

Обратите внимание, последняя строка файла начинается с `^`.
Это означает, что метка на предыдущей строке является аннотированной меткой и данная строка -- это коммит, на который аннотированная метка указывает.

[[r_data_recovery]]
==== Восстановление данных

В какой-то момент при работе с Git вы можете нечаянно потерять коммит.
Как правило, такое случается, когда вы удаляете ветку, в которой находились некоторые наработки, а потом оказывается, что они всё-таки были нужными; либо вы выполнили `git reset --hard`, тем самым отказавшись от коммитов, которые затем понадобились.
Как же в таком случае заполучить свои коммиты обратно?

Ниже приведён пример, в котором мы сбрасываем ветку `master` с потерей данных до более раннего состояния, а затем восстанавливаем потерянные коммиты.
Для начала, давайте посмотрим, как сейчас выглядит история изменений:

[source,console]
----
$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Теперь сбросим ветку `master` на третий коммит:

[source,console]
----
$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Итак, теперь два последних коммита по-настоящему потеряны -- они не достижимы ни из одной ветки.
Необходимо найти SHA-1 последнего коммита и создать ветку, указывающую на неё.
Сложность в том, чтобы узнать этот самый SHA-1, ведь вряд ли вы его запомнили, да?

Зачастую самый быстрый способ -- использование команды `git reflog`.
Дело в том, что во время вашей работы Git записывает все изменения HEAD.
Каждый раз при переключении веток и коммитов изменений, добавляется запись в reflog.
reflog также обновляется командой `git update-ref` -- это, кстати, хорошая причина использовать именно эту команду, а не вручную записывать SHA-1 в ref-файлы, как было показано в <<r_git_refs>>.
Вы можете посмотреть где находился указатель HEAD в любой момент времени, запустив `git reflog`:

[source,console]
----
$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: modified repo.rb a bit
484a592 HEAD@{2}: commit: added repo.rb
----

Здесь мы видим два коммита, на которые когда-то указывал HEAD, однако информации не так уж и много.
Более интересные выводы можно получить, используя `git log -g`; получим привычный лог, но для записей из reflog:

[source,console]
----
$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: updating HEAD
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:22:37 2009 -0700

		third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: updating HEAD
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

       modified repo.rb a bit
----

Похоже, что последний коммит -- это и есть тот, который мы потеряли; и его можно восстановить, создав ветку, указывающую на него.
Например, создадим ветку с именем `recover-branch`, указывающую на этот коммит (`ab1afef`):

[source,console]
----
$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Здорово!
Теперь у нас есть ветка `recover-branch`, указывающая туда, куда ранее указывал `master`, тем самым делая потерянные коммиты вновь доступными.
Теперь, положим, потерянная ветка по какой-либо причине не попала в reflog, для этого удалим восстановленную ветку и весь reflog.
Теперь два первых коммита недоступны ниоткуда:

[source,console]
----
$ git branch -D recover-branch
$ rm -Rf .git/logs/
----

Данные reflog хранятся в директории `.git/logs/`, которую мы только что удалили, поэтому теперь у нас нет reflog.
Как теперь восстановить коммиты?
Один из вариантов -- использование утилиты `git fsck`, проверяющую внутреннюю базу данных на целостность.
Если выполнить её с ключом `--full`, будут показаны все объекты, недостижимые из других объектов:

[source,console]
----
$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293
----

В данном случае потерянный коммит указан после слов "dangling commit" ("висячий коммит").
Его можно восстановить аналогичным образом, добавив ветку, указывающую на этот SHA-1.

[[r_removing_objects]]
==== Removing Objects

Git -- замечательный инструмент с кучей классных фич, но некоторые из них способны и навредить.
Например, команда `git clone` загружает проект вместе со всей историей, включая все версии всех файлов.
Это нормально, если в репозитории хранится только исходный код, так как Git хорошо оптимизирован под такой тип данных и может эффективно сжимать их.
Однако, если когда-либо в проект был добавлен большой файл, каждый, кто потом захочет клонировать проект, будет вынужден скачивать этот файл, даже если он был удалён в следующем же коммите.
Он будет в базе всегда, просто потому, что он доступен в истории.

Это может стать большой проблемой при конвертации Subversion или Perforce репозиториев в Git.
В этих системах вам не нужно загружать всю историю, поэтому добавление больших файлов не имеет там особых последствий.
Если при импорте из другой системы или при каких-либо других обстоятельствах стало ясно, что ваш репозиторий намного больше, чем он должен быть, то как раз сейчас мы расскажем, как можно найти и удалить большие объекты.

*Предупреждаем: дальнейшие действия разрушат историю изменений.*
Каждый коммит, начиная с самого раннего, из которого нужно удалить большой файл, будет переписан.
Если сделать это непосредственно после импорта, пока никто ещё не работал с репозиторием, то всё окей, иначе придётся сообщать всем участникам о необходимости перемещения их правок на новые коммиты.

Для примера добавим большой файл в тестовый репозиторий, удалим его в следующем коммите, а потом найдём и удалим его полностью из базы.
Для начала добавим большой файл в нашу историю:

[source,console]
----
$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz > git.tgz
$ git add git.tgz
$ git commit -m 'add git tarball'
[master 7b30847] add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz
----

Упс, мы нечаянно.
Нам лучше избавится от этого файла:

[source,console]
----
$ git rm git.tgz
rm 'git.tgz'
$ git commit -m 'oops - removed large tarball'
[master dadf725] oops - removed large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz
----

Теперь запустим сборщик мусора и посмотрим, сколько места мы занимаем:

[source,console]
----
$ git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)
----

Чтобы быстро узнать, сколько места занято, можно воспользоваться командой `count-objects`:

[source,console]
----
$ git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0
----

Строка `size-pack` -- это размер pack-файлов в килобайтах, то есть всего занято почти 5 MБ.
Перед последним коммитом использовалось около 2 КБ -- очевидно, удаление файла не удалило его из истории.
Всякий раз, когда кто-либо захочет склонировать этот репозиторий, ему придётся скачивать все 5 МБ для того, чтобы заполучить этот крошечный проектик, просто потому, что однажды вы имели неосторожность добавить большой блоб!
Давайте же исправим это!

Для начала найдём проблемный файл.
В данном случае, мы заранее знали, что это за файл.
Но если бы не знали, как можно было бы определить, какие файлы занимают много места?
При вызове `git gc` все объекты упаковываются в один pack-файл, но, несмотря на это, определить самые крупные файлы можно, запустив служебную команду `git verify-pack`, и отсортировав её вывод по третьей колонке, в которой записан размер файла.
Так как нас интересуют самые крупный файлы, оставим три последние строки с помощью `tail`:

[source,console]
----
$ git verify-pack -v .git/objects/pack/pack-29…69.idx \
  | sort -k 3 -n \
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438
----

Большой объект в самом внизу, его размер -- 5 МБ.
Для того чтобы узнать, что это за файл, воспользуемся командой `rev-list`, которая уже упоминалась в главе <<ch08-customizing-git#r_enforcing_commit_message_format>>.
Если передать ей ключ `--objects`, она выдаст хеши всех коммитов, а также хеши объектов и соответствующие им имена файлов.
Воспользуемся этим для определения имени выбранного объекта:

[source,console]
----
$ git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz
----

Теперь необходимо удалить данный файл из всех деревьев в прошлом.
Легко получить все коммиты, которые меняли данный файл:

[source,console]
----
$ git log --oneline --branches -- git.tgz
dadf725 oops - removed large tarball
7b30847 add git tarball
----

Необходимо переписать все коммиты, начиная с `7b30847` для полного удаления этого файла из истории.
Воспользуемся командой `filter-branch`, о которой мы писали в <<ch07-git-tools#r_rewriting_history>>:

[source,console]
----
$ git filter-branch --index-filter \
  'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten
----

Опция `--index-filter` похожа на `--tree-filter`, использовавшуюся в главе <<ch07-git-tools#r_rewriting_history>>, за исключением того, что вместо передачи команды, модифицирующей файлы на диске, мы используем команду, изменяющую файлы в индексе.

Вместо удаления файла чем-то вроде `rm file`, мы используем `git rm --cached`, так как нам надо удалить файл из индекса, а не с диска.
Причина, по которой мы делаем именно так -- скорость: нет необходимости извлекать каждую ревизию на диск, чтобы применить фильтр, а это может очень сильно ускорить процесс.
Если хотите, можете использовать и `tree-filter` для получения аналогичного результата.
Опция `--ignore-unmatch` команды `git rm` отключает вывод сообщения об ошибке в случае отсутствия файлов, соответствующих шаблону.
Ещё один момент: мы указали команде `filter-branch` переписывать историю, начиная с коммита `7b30847`, потому что мы знаем, что именно в этом изменении впервые появилась проблема.
По умолчанию перезапись начинается с самого первого состояния, что потребовало бы гораздо больше времени.

Теперь история не содержит ссылок на данный файл.
Однако, в reflog и в новом наборе ссылок, добавленном Git в `.git/refs/original` после выполнения `filter-branch`, ссылки на него всё ещё присутствуют, поэтому необходимо их удалить, а потом переупаковать базу.
Необходимо избавиться от всех возможных ссылок на старые коммиты перед переупаковкой:

[source,console]
----
$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)
----

Проверим, сколько места удалось освободить:

[source,console]
----
$ git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
----

Размер упакованного репозитория сократился до 8 КБ, что намного лучше, чем 5 МБ.
Из значения поля size видно, что большой объект всё ещё хранится в одном из ваших "рыхлых" объектов, но, что самое главное, при любой последующей отправке данных наружу (а значит и при последующих клонированиях репозитория) он передаваться не будет.
Если очень хочется, можно удалить его навсегда локально, выполнив `git prune --expire`:

[source,console]
----
$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
----

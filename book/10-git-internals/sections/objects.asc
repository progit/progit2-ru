[[r_objects]]
=== Объекты Git

Git -- контентно-адресуемая файловая система.
Здорово.
Что это означает?
А означает это, по сути, что Git -- простое хранилище ключ-значение.
Можно добавить туда любые данные, в ответ будет выдан ключ по которому их можно извлечь обратно.
Например, можно воспользоваться служебной командой `hash-object`, добавляющей данные в директорию `.git` и возвращающей ключ.
Для начала создадим новый Git-репозиторий и убедимся, что директория `objects` пуста:

[source,console]
----
$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
----

Git проинициализировал директорию `objects` и создал в нём пустые поддиректории `pack` и `info`.
Теперь добавим кое-какое текстовое содержимое в базу Git:

[source,console]
----
$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
----

Ключ `-w` указывает команде `hash-object`, что объект необходимо сохранить, иначе команда просто вернёт ключ.
Флаг `--stdin` указывает, что данные необходимо считать из потока стандартного ввода, в противном случае `hash-object` ожидает путь к файлу в качестве аргумента.
Вывод команды -- 40-символьная контрольная сумма.
Это хеш SHA-1 -- контрольная сумма содержимого и заголовка, который будет рассмотрен позднее.
Теперь можно увидеть, в каком виде сохранены ваши данные:

[source,console]
----
$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Мы видим новый файл в директории `objects`.
Это и есть начальное внутреннее представление данных в Git -- один файл на единицу хранения с именем, являющимся контрольной суммой содержимого и заголовка.
Первые два символа SHA-1 определяют поддиректорию файла внутри `objects`, остальные 38 -- собственно, имя.

Получить обратно содержимое объекта можно командой `cat-file`.
Она подобна швейцарскому ножу для проверки объектов в Git.
Ключ `-p` означает автоматическое определение типа содержимого и вывод содержимого на печать в удобном виде:

[source,console]
----
$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
----

Теперь вы умеете добавлять данные в Git и извлекать их обратно.
То же самое можно делать и с файлами.
Например, можно проверсионировать один файл.
Для начала, создадим новый файл и сохраним его в базе данных Git:

[source,console]
----
$ echo 'version 1' > test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
----

Теперь изменим файл и сохраним его в базе ещё раз:

[source,console]
----
$ echo 'version 2' > test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
----

Теперь в базе содержатся две версии файла, а также самый первый сохранённый объект:

[source,console]
----
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Теперь можно откатить файл к его первой версии:

[source,console]
----
$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt
$ cat test.txt
version 1
----

или ко второй:

[source,console]
----
$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt
$ cat test.txt
version 2
----

Однако запоминать хеш для каждой версии неудобно, к тому же теряется имя файла, сохраняется лишь содержимое.
Объекты такого типа называют блобами (англ. blob -- binary large object).
Имея SHA-1 объекта, можно попросить Git показать нам его тип с помощью команды `cat-file -t`:

[source,console]
----
$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
----

[[r_tree_objects]]
==== Деревья

Следующий тип объектов, который мы рассмотрим, -- деревья -- решают проблему хранения имён файлов, а также позволяют хранить группы файлов вместе.
Git хранит данные сходным с файловыми системами UNIX способом, но в немного упрощённом виде.
Содержимое хранится в деревьях и блобах, где дерево соответствует директории на файловой системе, а блоб более или менее соответствует inode или содержимому файла.
Дерево может содержать одну или более записей, содержащих SHA-1 хеш, соответствующий блобу или поддереву, права доступа к файлу, тип и имя файла.
Например, дерево последнего коммита в проекте может выглядеть следующим образом:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
----

Запись `master^{tree}` указывает на дерево, соответствующее последнему коммиту ветки `master`.
Обратите внимание, что поддиректория `lib` -- не блоб, а указатель на другое дерево:

[source,console]
----
$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
----

Концептуально, данные хранятся в Git примерно так:

.Упрощённая модель данных Git.
image::images/data-model-1.png[Упрощённая модель данных Git.]

Можно создать дерево самому.
Обычно Git создаёт деревья на основе индекса, затем сохраняя их в БД.
Поэтому для создания дерева необходимо проиндексировать какие-нибудь файлы.
Для создания индекса из одной записи -- первой версии файла test.txt -- воспользуемся низкоуровневой командой `update-index`.
Данная команда может искусственно добавить более раннюю версию test.txt в новый индекс.
Необходимо передать опции `--add`, т.к. файл ещё не существует в индексе (да и самого индекса ещё нет), и `--cacheinfo`, т.к. добавляемого файла нет в рабочей директории, но он есть в базе данных.
Также необходимо передать права доступа, хеш и имя файла:

[source,console]
----
$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt
----

В данном случае права доступа -- `100644`, означают обычный файл.
Другие возможные варианты: `100755` -- исполняемый файл, `120000` -- символическая ссылка.
Права доступа в Git сделаны по аналогии с режимами доступа в UNIX, но они гораздо менее гибки: данные три режима -- единственные доступные для файлов (блобов) в Git (хотя существуют и другие режимы, используемые для директорий и дочерних модулей).

Теперь можно воспользоваться командой `write-tree` для сохранения индекса в виде дерева.
Здесь опция `-w` не требуется -- вызов `write-tree` автоматически создаёт дерево из индекса, если такого дерева ещё не существует:

[source,console]
----
$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt
----

Можно проверить, что мы действительно создали дерево:

[source,console]
----
$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree
----

Давайте создадим новое дерево со второй версией файла test.txt и ещё одним файлом:

[source,console]
----
$ echo 'new file' > new.txt
$ git update-index test.txt
$ git update-index --add new.txt
----

Теперь в индексе содержится новая версия файла test.txt и новый файл new.txt.
Зафиксируем изменения, сохранив состояние индекса в новое дерево, и посмотрим, что из этого вышло:

[source,console]
----
$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Обратите внимание, что в данном дереве находятся записи для обоих файлов, а также, что хеш файла test.txt это хеш "второй версии" этого файла (`1f7a7a`).
Для интереса, добавим первое дерево как поддиректорию текущего.
Вычитать дерево в индекс можно командой `read-tree`.
В нашем случае, чтобы прочитать уже существующее дерево в индекс и сделать его поддеревом, необходимо использовать опцию `--prefix`:

[source,console]
----
$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Если бы вы сейчас вычитали только что сохранённое дерево в рабочую директорию, вы бы увидели два файла в корне рабочей директории и поддиректорию `bak` с первой версией файла `test.txt`.
Представьте, что данные хранятся в Git следующим образом:

.Структура данных Git для последнего дерева.
image::images/data-model-2.png[Структура данных Git для последнего дерева.]

[[r_git_commit_objects]]
==== Commit Objects

У вас есть три дерева, соответствующих разным состояниям проекта, но предыдущая проблема с необходимостью запоминать все три значения SHA-1, чтобы иметь возможность восстановить какое-либо из этих состояний, ещё не решена.
К тому же у нас нет никакой информации о том, кто, когда и почему сохранил их.
Такие данные -- основная информация, хранимая в коммите.

Для создания коммита необходимо вызвать команду `commit-tree` и задать SHA-1 нужного дерева и, если необходимо, родительские коммиты.
Для начала создадим коммит для самого первого дерева:

[source,console]
----
$ echo 'first commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d
----

Просмотреть вновь созданный коммит можно командой `cat-file`:

[source,console]
----
$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon <schacon@gmail.com> 1243040974 -0700
committer Scott Chacon <schacon@gmail.com> 1243040974 -0700

first commit
----

Формат коммита прост: в нём указано дерево верхнего уровня, соответствующее состоянию проекта на некоторый момент; имена автора и коммиттера (берутся из полей конфигурации `user.name` и `user.email`); временная метка; пустая строка и сообщение коммита.

Далее, создадим ещё два коммита, каждый из которых будет ссылаться на предыдущий:

[source,console]
----
$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9
----

Каждый из этих коммитов указывает на одно из деревьев-состояний проекта.
Вы не поверите, но теперь у нас есть полноценная Git-история, которую можно посмотреть командой `git log`, указав хеш последнего коммита:

[source,console]
----
$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)
----

Здорово, правда?
Мы только что выполнили несколько низкоуровневых операций и получили "настоящий" Git-репозиторий с историей без единой высокоуровневой команды!
Именно так и работает Git, когда выполняются команды `git add` и `git commit` -- сохраняет блобы для изменённых файлов, обновляет индекс, записывает его в виде дерева, и, наконец, фиксирует изменения в коммите, ссылающемся на это дерево и предшествующие коммиты.
Эти три основных вида объектов Git -- блоб, дерево и коммит -- сохраняются в виде отдельных файлов в директории `.git/objects`.
Вот все объекты, которые сейчас находятся в директории, с примером с комментариями чему они соответствуют:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
----

Если пройти по всем внутренним ссылкам, получится граф объектов такой, как на рисунке:

.Все объекты в директории Git.
image::images/data-model-3.png[Все объекты в директории Git.]

==== Хранение объектов

Ранее мы упоминали, что заголовок сохраняется вместе с содержимым.
Давайте посмотрим, как Git сохраняет объекты на диске.
Мы рассмотрим сохранение блоба -- в данном случае это будет строка "как дела, Док?" -- на языке Ruby.

Для запуска интерактивного интерпретатора воспользуйтесь командой `irb`:

[source,console]
----
$ irb
>> content = "what is up, doc?"
=> "what is up, doc?"
----

Git создаёт заголовок, начинающийся с типа объекта, в данном случае это блоб.
Далее идут пробел, размер содержимого и в конце нулевой байт:

[source,console]
----
>> header = "blob #{content.length}\0"
=> "blob 16\u0000"
----

Git склеивает заголовок и содержимое, а потом вычисляет SHA-1 сумму для полученного результата.
В Ruby значение SHA-1 для строки можно получить, подключив соответствующую библиотеку командой `require` и затем вызвав `Digest::SHA1.hexdigest()`:

[source,console]
----
>> store = header + content
=> "blob 16\u0000what is up, doc?"
>> require 'digest/sha1'
=> true
>> sha1 = Digest::SHA1.hexdigest(store)
=> "bd9dbf5aae1a3862dd1526723246b20206e5fc37"
----

Git сжимает новые данные при помощи zlib, в Ruby это можно сделать с помощью одноимённой библиотеки.
Сперва необходимо подключить её, а затем вызвать `Zlib::Deflate.deflate()`:

[source,console]
----
>> require 'zlib'
=> true
>> zlib_content = Zlib::Deflate.deflate(store)
=> "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"
----

После этого запишем сжатую zlib'ом строку в объект на диск.
Определим путь к файлу, который будет записан (первые два символа хеша используются в качестве названия директории, оставшиеся 38 -- в качестве имени файла в ней).
В Ruby для безопасного создания нескольких вложенных директорий можно использовать функцию `FileUtils.mkdir_p()`.
Далее, откроем файл вызовом `File.open()` и запишем сжатые данные вызовом `write()` для полученного файлового дескриптора:

[source,console]
----
>> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=> ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
>> require 'fileutils'
=> true
>> FileUtils.mkdir_p(File.dirname(path))
=> ".git/objects/bd"
>> File.open(path, 'w') { |f| f.write zlib_content }
=> 32
----

Вот и всё, мы создали корректный блоб Git.
Все другие объекты создаются аналогично, меняется лишь запись о типе в заголовке (blob, commit либо tree).
Стоит добавить, что хотя в блобе может храниться почти любое содержимое, содержимое деревьев и коммитов записывается в очень строгом формате.

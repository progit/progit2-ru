=== Pack-файлы

Вернёмся к базе объектов в нашем тестовом репозитории. 
К этому моменту их должно быть 11 штук: 4 блоба, 3 дерева, 3 коммита и одна метка:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
----

Git сжал содержимое этих файлов при помощи zlib, к тому же вы не записывали много данных, поэтому все эти файлы вместе занимают всего 925 байт. 
Для того чтобы продемонстрировать одну интересную возможность Git'а, добавим файл побольше.
Добавим файл `repo.rb` из библиотеки Grit, он занимает примерно 22 Кбайт:

[source,console]
----
$ curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb > repo.rb
$ git add repo.rb
$ git commit -m 'added repo.rb'
[master 484a592] added repo.rb
 3 files changed, 709 insertions(+), 2 deletions(-)
 delete mode 100644 bak/test.txt
 create mode 100644 repo.rb
 rewrite test.txt (100%)
----

If you look at the resulting tree, you can see the SHA-1 value your repo.rb file got for the blob object:
Если вы посмотрите на полученное дерево, то увидите значение SHA-1, которое получил блоб для файла repo.rb:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
----

Используем `git cat-file`, чтобы увидеть размер этого объекта:

[source,console]
----
$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
22044
----

Теперь немного изменим данный файл и посмотрим на результат:

[source,console]
----
$ echo '# testing' >> repo.rb
$ git commit -am 'modified repo a bit'
[master 2431da6] modified repo.rb a bit
 1 file changed, 1 insertion(+)
----

Взглянув на дерево, полученное в результате коммита, мы увидим любопытную вещь:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
----

Теперь файлу repo.rb соответствует другой объект-блоб. Это означает, что даже одна единственная строка, добавленная в конец 400-строчного файла, требует создания абсолютно нового объекта:

[source,console]
----
$ git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e
22054
----

Теперь у вас есть два почти одинаковых объекта, занимающих по 22Kбайт на диске.
Было бы неплохо, если бы Git сохранял только один объект целиком, а другой как разницу между ним и первым объектом?

Оказывается,что он так и делает.
The initial format in which Git saves objects on disk is called a ``loose'' object format.
Первоначальный формат для сохранения объектов в Git'е называется ``рыхлым'' (``loose'') форматом объектов. 
Однако, время от времени Git упаковывает несколько таких объектов в один двоичный ``pack-файл'' (pack от англ. — упаковывать, уплотнять) для экономии места на диске и повышения эффективности.
Это происходит, когда ``рыхлым'' объектов становится слишком много, при вызове `git gc` вручную, а также при отправке изменений на удалённый сервер. 
Чтобы посмотреть, как происходит упаковка, можно выполнить команду `git gc`:

[source,console]
----
$ git gc
Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (18/18), done.
Total 18 (delta 3), reused 0 (delta 0)
----

Теперь, при просмотре каталога с объектами, вы обнаружите, что большая часть объектов исчезла, зато появились два новых файла:

[source,console]
----
$ find .git/objects -type f
.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack
----

Оставшиеся объекты — блобы, на которые не указывает ни один коммит. В нашем случае это созданные ранее объекты: содержащий строку ``what is up, doc?'', и блоб содержащий ``test content''. 
В силу того, что ни в одном коммите данные файлы не присутствуют, они считаются "висячими" и не упаковываются.

Остальные файлы — это pack-файл и его индекс.
Pack-файл — это файл, который теперь содержит все объекты, которые были удалены. 
А индекс — это файл, в котором записаны их смещения в pack-файле, что даёт возможность быстро найти нужный объект.
Упаковка данных положительно повлияла на общий размер файлов, если до вызова `gc` они занимали примерно 22 Кбайта, то pack-файл занимает всего 7 Кбайт. 
В данном случае упаковка объектов позволила сократить на ⅔ занятое на диске место.

Как Git это делает?
When Git packs objects, it looks for files that are named and sized similarly, and stores just the deltas from one version of the file to the next.
При упаковке Git ищет файлы, которые похожи по имени и размеру, и сохраняет только разницу между предыдущей и следующей версиями файла. 
Рассмотрим pack-файл подробнее, чтобы понять, какие действия были выполнены для сжатия. 
Для отображения содержимого упакованного файла существует служебная команда `git verify-pack`:

[source,console]
----
$ git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756
d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874
fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132
deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178
d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445
b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \
  b042a60ef7dff760008df33cee372b945b6e884e
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282
non delta: 15 objects
chain length = 1: 3 objects
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok
----

Здесь блоб `033b4`, который, как вы помните, был первой версией файла repo.rb, ссылается на блоб `b042a`, который был второй его версией.
Третья колонка в выводе — это размер содержимого объекта. 
Как видите, содержимое `b042a` занимает 22 Кбайт, при этом содержимое `033b4` занимает всего лишь 9 байт. 
Что интересно, вторая версия сохраняется полностью, а исходная — в виде дельты. 
Это связано с тем, что необходимость получения доступа к последней версии файла является более вероятной.

Еще один положительный момент состоит в том, что переупаковку можно выполнять в любое время. 
Время от времени Git будет выполнять её автоматически, чтобы сэкономить место на диске. 
Если вдруг этого недостаточно, всегда можно выполнить `git gc` вручную.
